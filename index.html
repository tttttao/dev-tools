<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¼€å‘å·¥å…·ç®±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* å¯¼èˆªèœå•æ ·å¼ */
        .nav-bar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            padding: 0 20px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            height: 60px;
        }

        .nav-logo {
            font-size: 1.3rem;
            font-weight: 600;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 40px;
            cursor: pointer;
        }

        .nav-logo:hover {
            color: #764ba2;
        }

        .nav-menu {
            display: flex;
            gap: 5px;
            list-style: none;
        }

        .nav-item {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            color: #555;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-item:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .nav-item.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .nav-item .nav-icon {
            font-size: 16px;
        }

        /* ä¸»å†…å®¹åŒºåŸŸ */
        .main-content {
            flex: 1;
            padding: 30px 20px;
            overflow-y: auto;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* å·¥å…·é¡µé¢ */
        .tool-page {
            display: none;
        }

        .tool-page.active {
            display: block;
        }

        /* é¦–é¡µæ ·å¼ */
        .home-header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .home-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .home-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }

        .tool-card-home {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .tool-card-home:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .tool-card-home .card-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 15px;
        }

        .tool-card-home h3 {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 8px;
        }

        .tool-card-home p {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
        }

        /* å·¥å…·å¡ç‰‡é€šç”¨æ ·å¼ */
        .tool-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .tool-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .tool-header .icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .tool-header h2 {
            font-size: 1.4rem;
            color: #333;
            font-weight: 600;
        }

        /* è½¬æ¢å™¨å¸ƒå±€ */
        .converter-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .converter-section {
            display: flex;
            flex-direction: column;
        }

        .converter-section h3 {
            font-size: 0.95rem;
            color: white;
            margin-bottom: 10px;
            padding: 10px 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .control-section {
            margin-top: 20px;
            text-align: center;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e1e8ed;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .message {
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .message.error {
            background: #fff5f5;
            color: #e53e3e;
            border-left: 4px solid #e53e3e;
        }

        .message.success {
            background: #f0fff4;
            color: #38a169;
            border-left: 4px solid #38a169;
        }

        /* DDLè§£æå™¨æ ·å¼ */
        .ddl-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .ddl-input-section {
            display: flex;
            flex-direction: column;
        }

        .ddl-input-section h3 {
            font-size: 0.95rem;
            color: white;
            margin-bottom: 10px;
            padding: 10px 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        .ddl-control-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ddl-control-section .buttons {
            flex-direction: column;
        }

        .ddl-output-section {
            grid-column: 1 / -1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 200px;
        }

        .ddl-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 150px;
            color: #999;
        }

        .ddl-placeholder span {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .table-info {
            margin-bottom: 20px;
        }

        .table-info h4 {
            font-size: 1.1rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .table-info .table-name {
            color: #667eea;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .table-info .table-comment {
            color: #666;
            font-size: 0.9rem;
        }

        .ddl-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .ddl-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: 500;
            white-space: nowrap;
        }

        .ddl-table td {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            vertical-align: top;
        }

        .ddl-table tr:last-child td {
            border-bottom: none;
        }

        .ddl-table tr:hover {
            background: #f8f9fa;
        }

        .field-name {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 500;
            color: #333;
        }

        .field-type {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #667eea;
        }

        .field-nullable {
            text-align: center;
        }

        .nullable-yes {
            color: #38a169;
        }

        .nullable-no {
            color: #e53e3e;
        }

        .field-default {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #666;
            font-size: 12px;
        }

        .field-comment {
            color: #555;
            max-width: 200px;
        }

        .index-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin: 2px;
            white-space: nowrap;
        }

        .index-primary {
            background: linear-gradient(45deg, #f6e05e, #ecc94b);
            color: #744210;
        }

        .index-unique {
            background: linear-gradient(45deg, #68d391, #48bb78);
            color: #22543d;
        }

        .index-normal {
            background: linear-gradient(45deg, #63b3ed, #4299e1);
            color: #1a365d;
        }

        .index-fulltext {
            background: linear-gradient(45deg, #b794f4, #9f7aea);
            color: #44337a;
        }

        .index-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .index-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px dashed #e1e8ed;
        }

        .index-section h5 {
            font-size: 1rem;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .index-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .index-item {
            background: white;
            padding: 12px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .index-item .index-name {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 500;
            color: #333;
            min-width: 150px;
        }

        .index-item .index-columns {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #667eea;
            flex: 1;
        }

        .index-item .index-table {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #38a169;
            font-size: 12px;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .nav-container {
                flex-direction: column;
                height: auto;
                padding: 15px 0;
            }

            .nav-logo {
                margin-right: 0;
                margin-bottom: 10px;
            }

            .nav-menu {
                flex-wrap: wrap;
                justify-content: center;
            }

            .nav-item {
                padding: 8px 15px;
                font-size: 13px;
            }

            .converter-container,
            .ddl-container {
                grid-template-columns: 1fr;
            }

            .home-header h1 {
                font-size: 1.8rem;
            }

            .tools-grid {
                grid-template-columns: 1fr;
            }

            .buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .ddl-table {
                font-size: 11px;
            }

            .ddl-table th,
            .ddl-table td {
                padding: 8px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="nav-bar">
        <div class="nav-container">
            <div class="nav-logo" onclick="showPage('home')">
                ğŸ› ï¸ å¼€å‘å·¥å…·ç®±
            </div>
            <ul class="nav-menu">
                <li class="nav-item active" data-page="home" onclick="showPage('home')">
                    <span class="nav-icon">ğŸ </span>
                    é¦–é¡µ
                </li>
                <li class="nav-item" data-page="php-json" onclick="showPage('php-json')">
                    <span class="nav-icon">ğŸ”„</span>
                    PHP/JSONè½¬æ¢
                </li>
                <li class="nav-item" data-page="ddl-parser" onclick="showPage('ddl-parser')">
                    <span class="nav-icon">ğŸ“‹</span>
                    DDLè§£æå™¨
                </li>
            </ul>
        </div>
    </nav>

    <!-- ä¸»å†…å®¹åŒºåŸŸ -->
    <main class="main-content">
        <div class="container">
            <!-- é¦–é¡µ -->
            <div id="page-home" class="tool-page active">
                <div class="home-header">
                    <h1>ğŸ› ï¸ å¼€å‘å·¥å…·ç®±</h1>
                    <p>å®ç”¨çš„å¼€å‘å°å·¥å…·é›†åˆï¼Œæå‡ä½ çš„å¼€å‘æ•ˆç‡</p>
                </div>

                <div class="tools-grid">
                    <div class="tool-card-home" onclick="showPage('php-json')">
                        <div class="card-icon">ğŸ”„</div>
                        <h3>PHPæ•°ç»„ â‡„ JSON è½¬æ¢å™¨</h3>
                        <p>å¿«é€Ÿåœ¨ PHP æ•°ç»„æ ¼å¼å’Œ JSON æ ¼å¼ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼Œæ”¯æŒåµŒå¥—ç»“æ„å’Œå„ç§æ•°æ®ç±»å‹ã€‚</p>
                    </div>

                    <div class="tool-card-home" onclick="showPage('ddl-parser')">
                        <div class="card-icon">ğŸ“‹</div>
                        <h3>DDL è§£æå™¨</h3>
                        <p>è§£æ MySQL DDL è¯­å¥ï¼ˆCREATE TABLE / CREATE INDEXï¼‰ï¼Œç”Ÿæˆæ¸…æ™°çš„è¡¨æ ¼å±•ç¤ºå­—æ®µä¿¡æ¯å’Œç´¢å¼•å…³ç³»ã€‚</p>
                    </div>
                </div>
            </div>

            <!-- PHP/JSON è½¬æ¢å™¨ -->
            <div id="page-php-json" class="tool-page">
                <div class="tool-card">
                    <div class="tool-header">
                        <div class="icon">ğŸ”„</div>
                        <h2>PHPæ•°ç»„ â‡„ JSON è½¬æ¢å™¨</h2>
                    </div>

                    <div class="converter-container">
                        <div class="converter-section">
                            <h3>PHPæ•°ç»„æ ¼å¼</h3>
                            <textarea id="phpInput" placeholder="è¯·è¾“å…¥PHPæ•°ç»„æ ¼å¼ï¼Œä¾‹å¦‚ï¼š
array(
    'name' => 'å¼ ä¸‰',
    'age' => 25,
    'skills' => array('PHP', 'JavaScript', 'Python')
)

æˆ–è€…ç®€åŒ–æ ¼å¼ï¼š
[
    'name' => 'å¼ ä¸‰',
    'age' => 25,
    'skills' => ['PHP', 'JavaScript', 'Python']
]"></textarea>
                        </div>

                        <div class="converter-section">
                            <h3>JSONæ ¼å¼</h3>
                            <textarea id="jsonInput" placeholder='è¯·è¾“å…¥JSONæ ¼å¼ï¼Œä¾‹å¦‚ï¼š
{
    "name": "å¼ ä¸‰",
    "age": 25,
    "skills": ["PHP", "JavaScript", "Python"]
}'></textarea>
                        </div>
                    </div>

                    <div class="control-section">
                        <div class="buttons">
                            <button class="btn btn-primary" onclick="phpToJson()">PHP â†’ JSON</button>
                            <button class="btn btn-primary" onclick="jsonToPhp()">JSON â†’ PHP</button>
                            <button class="btn btn-secondary" onclick="clearPhpJson()">æ¸…ç©º</button>
                        </div>

                        <div class="message error" id="phpJsonErrorMsg"></div>
                        <div class="message success" id="phpJsonSuccessMsg"></div>
                    </div>
                </div>
            </div>

            <!-- DDL è§£æå™¨ -->
            <div id="page-ddl-parser" class="tool-page">
                <div class="tool-card">
                    <div class="tool-header">
                        <div class="icon">ğŸ“‹</div>
                        <h2>DDL è§£æå™¨</h2>
                    </div>

                    <div class="ddl-container">
                        <div class="ddl-input-section">
                            <h3>è¾“å…¥DDLè¯­å¥</h3>
                            <textarea id="ddlInput" placeholder="æ”¯æŒ CREATE TABLE å’Œ CREATE INDEX è¯­å¥ï¼Œä¾‹å¦‚ï¼š

CREATE TABLE `users` (
    `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ç”¨æˆ·ID',
    `username` varchar(50) NOT NULL COMMENT 'ç”¨æˆ·å',
    `email` varchar(100) NOT NULL COMMENT 'é‚®ç®±',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_username` (`username`),
    KEY `idx_email` (`email`)
) ENGINE=InnoDB COMMENT='ç”¨æˆ·è¡¨';

CREATE INDEX idx_created_at ON users (created_at);
CREATE UNIQUE INDEX uk_phone ON users (phone);"></textarea>
                        </div>

                        <div class="ddl-control-section">
                            <div class="buttons">
                                <button class="btn btn-primary" onclick="parseDDL()">è§£æDDL</button>
                                <button class="btn btn-secondary" onclick="clearDDL()">æ¸…ç©º</button>
                                <button class="btn btn-secondary" onclick="copyTableAsMarkdown()">å¤åˆ¶ä¸ºMarkdown</button>
                            </div>
                            <div class="message error" id="ddlErrorMsg"></div>
                            <div class="message success" id="ddlSuccessMsg"></div>
                        </div>
                    </div>

                    <div class="ddl-output-section" id="ddlOutput">
                        <div class="ddl-placeholder">
                            <span>ğŸ“Š</span>
                            <p>è§£æç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // ==================== é¡µé¢å¯¼èˆª ====================
        function showPage(pageId) {
            // éšè—æ‰€æœ‰é¡µé¢
            document.querySelectorAll('.tool-page').forEach(page => {
                page.classList.remove('active');
            });
            
            // æ˜¾ç¤ºç›®æ ‡é¡µé¢
            document.getElementById('page-' + pageId).classList.add('active');
            
            // æ›´æ–°å¯¼èˆªèœå•çŠ¶æ€
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.page === pageId) {
                    item.classList.add('active');
                }
            });

            // æ›´æ–° URL hash
            window.location.hash = pageId;
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥ hash
        window.addEventListener('load', () => {
            const hash = window.location.hash.slice(1);
            if (hash && document.getElementById('page-' + hash)) {
                showPage(hash);
            }
        });

        // ==================== PHP/JSON è½¬æ¢åŠŸèƒ½ ====================
        
        function showPhpJsonMessage(message, type = 'success') {
            const errorDiv = document.getElementById('phpJsonErrorMsg');
            const successDiv = document.getElementById('phpJsonSuccessMsg');
            
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';
            
            if (type === 'error') {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            } else {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
            }
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
            }, 3000);
        }

        function phpToJson() {
            const phpInput = document.getElementById('phpInput').value.trim();
            if (!phpInput) {
                showPhpJsonMessage('è¯·è¾“å…¥PHPæ•°ç»„æ ¼å¼', 'error');
                return;
            }

            try {
                let jsonResult;
                try {
                    jsonResult = smartParsePHPArray(phpInput);
                } catch (smartError) {
                    jsonResult = parsePHPArray(phpInput);
                }
                
                document.getElementById('jsonInput').value = JSON.stringify(jsonResult, null, 2);
                showPhpJsonMessage('è½¬æ¢æˆåŠŸï¼');
            } catch (error) {
                showPhpJsonMessage('è½¬æ¢å¤±è´¥ï¼š' + error.message, 'error');
            }
        }

        function jsonToPhp() {
            const jsonInput = document.getElementById('jsonInput').value.trim();
            if (!jsonInput) {
                showPhpJsonMessage('è¯·è¾“å…¥JSONæ ¼å¼', 'error');
                return;
            }

            try {
                const jsonObj = JSON.parse(jsonInput);
                const phpResult = convertToPHP(jsonObj);
                document.getElementById('phpInput').value = phpResult;
                showPhpJsonMessage('è½¬æ¢æˆåŠŸï¼');
            } catch (error) {
                showPhpJsonMessage('è½¬æ¢å¤±è´¥ï¼šè¯·æ£€æŸ¥JSONæ ¼å¼æ˜¯å¦æ­£ç¡®', 'error');
            }
        }

        function clearPhpJson() {
            document.getElementById('phpInput').value = '';
            document.getElementById('jsonInput').value = '';
            document.getElementById('phpJsonErrorMsg').style.display = 'none';
            document.getElementById('phpJsonSuccessMsg').style.display = 'none';
        }

        // PHPæ•°ç»„è§£æå™¨
        function parsePHPArray(phpString) {
            let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
            cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
            cleanString = cleanString.replace(/;$/, '');
            cleanString = replaceArraySyntax(cleanString);
            cleanString = replaceArrowSyntax(cleanString);
            cleanString = replaceSingleQuotes(cleanString);
            cleanString = replacePhpValues(cleanString);
            cleanString = fixKeyFormat(cleanString);
            return JSON.parse(cleanString);
        }
        
        function replaceArraySyntax(str) {
            let result = str;
            let changed = true;
            while (changed) {
                const before = result;
                result = result.replace(/\barray\s*\(/g, '[');
                changed = before !== result;
            }
            return balanceParentheses(result);
        }
        
        function balanceParentheses(str) {
            let result = '';
            let inString = false;
            let stringChar = '';
            let escaped = false;
            
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                
                if (escaped) {
                    result += char;
                    escaped = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escaped = true;
                    continue;
                }
                
                if (!inString && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (inString && char === stringChar) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    result += char;
                    continue;
                }
                
                if (char === '(') {
                    result += '[';
                } else if (char === ')') {
                    result += ']';
                } else {
                    result += char;
                }
            }
            
            return result;
        }
        
        function replaceArrowSyntax(str) {
            return str.replace(/((?:'[^'\\]*(?:\\.[^'\\]*)*'|"[^"\\]*(?:\\.[^"\\]*)*"|\w+|\d+))\s*=>\s*/g, function(match, key) {
                if (/^\d+$/.test(key)) return key + ': ';
                if (key.match(/^['"]/)) return key + ': ';
                return '"' + key + '": ';
            });
        }
        
        function fixKeyFormat(str) {
            return str.replace(/(\w+)(\s*:\s*)/g, function(match, key, colon) {
                if (!/^\d+$/.test(key) && !key.match(/^['"]/)) {
                    return '"' + key + '"' + colon;
                }
                return match;
            });
        }
        
        function replaceSingleQuotes(str) {
            let result = '';
            let inDoubleQuote = false;
            let escaped = false;
            
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                
                if (escaped) {
                    result += char;
                    escaped = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escaped = true;
                    continue;
                }
                
                if (char === '"') {
                    inDoubleQuote = !inDoubleQuote;
                    result += char;
                    continue;
                }
                
                if (inDoubleQuote) {
                    result += char;
                    continue;
                }
                
                if (char === "'") {
                    result += '"';
                } else {
                    result += char;
                }
            }
            
            return result;
        }
        
        function replacePhpValues(str) {
            let result = str.replace(/\b(true|false|null|TRUE|FALSE|NULL)\b/g, function(match) {
                return match.toLowerCase();
            });
            result = result.replace(/\bINF\b/g, '"Infinity"');
            result = result.replace(/\bNAN\b/g, '"NaN"');
            result = result.replace(/\b-INF\b/g, '"-Infinity"');
            return result;
        }
        
        // æ™ºèƒ½PHPæ•°ç»„è§£æå™¨
        function smartParsePHPArray(phpString) {
            let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
            cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
            cleanString = cleanString.replace(/;$/, '');
            
            const tokens = tokenize(cleanString);
            return parseTokens(tokens);
        }
        
        function tokenize(str) {
            const tokens = [];
            let i = 0;
            
            while (i < str.length) {
                const char = str[i];
                
                if (/\s/.test(char)) { i++; continue; }
                
                if (char === '"' || char === "'") {
                    const quote = char;
                    let value = '';
                    i++;
                    while (i < str.length && str[i] !== quote) {
                        if (str[i] === '\\' && i + 1 < str.length) {
                            value += str[i] + str[i + 1];
                            i += 2;
                        } else {
                            value += str[i];
                            i++;
                        }
                    }
                    tokens.push({type: 'STRING', value: value, quote: quote});
                    i++;
                    continue;
                }
                
                if (/\d/.test(char) || (char === '-' && /\d/.test(str[i + 1]))) {
                    let value = '';
                    if (char === '-') { value += char; i++; }
                    while (i < str.length && /[\d.]/.test(str[i])) {
                        value += str[i];
                        i++;
                    }
                    tokens.push({type: 'NUMBER', value: parseFloat(value)});
                    continue;
                }
                
                if (/[a-zA-Z_]/.test(char)) {
                    let value = '';
                    while (i < str.length && /[a-zA-Z0-9_]/.test(str[i])) {
                        value += str[i];
                        i++;
                    }
                    
                    if (value === 'array') {
                        tokens.push({type: 'ARRAY'});
                    } else if (['true', 'false', 'null'].includes(value.toLowerCase())) {
                        tokens.push({type: 'LITERAL', value: value.toLowerCase()});
                    } else {
                        tokens.push({type: 'IDENTIFIER', value: value});
                    }
                    continue;
                }
                
                if (char === '=' && str[i + 1] === '>') {
                    tokens.push({type: 'ARROW'});
                    i += 2;
                    continue;
                }
                
                const singleChars = {'[': 'LBRACKET', ']': 'RBRACKET', '(': 'LPAREN', ')': 'RPAREN', ',': 'COMMA'};
                if (singleChars[char]) {
                    tokens.push({type: singleChars[char]});
                    i++;
                    continue;
                }
                
                i++;
            }
            
            return tokens;
        }
        
        function parseTokens(tokens) {
            let pos = 0;
            
            function parseValue() {
                const token = tokens[pos];
                if (!token) throw new Error('æ„å¤–çš„è¾“å…¥ç»“æŸ');
                
                if (token.type === 'STRING') { pos++; return token.value; }
                if (token.type === 'NUMBER') { pos++; return token.value; }
                if (token.type === 'LITERAL') {
                    pos++;
                    return token.value === 'true' ? true : token.value === 'false' ? false : null;
                }
                if (token.type === 'LBRACKET' || token.type === 'ARRAY') return parseArray();
                
                throw new Error('æ— æ³•è§£æçš„å€¼: ' + JSON.stringify(token));
            }
            
            function parseArray() {
                const result = {};
                let isIndexedArray = true;
                let index = 0;
                
                if (tokens[pos]?.type === 'ARRAY') {
                    pos++;
                    if (tokens[pos]?.type === 'LPAREN') pos++;
                } else if (tokens[pos]?.type === 'LBRACKET') {
                    pos++;
                }
                
                while (pos < tokens.length && tokens[pos]?.type !== 'RBRACKET' && tokens[pos]?.type !== 'RPAREN') {
                    let key = index;
                    
                    if (pos + 1 < tokens.length && tokens[pos + 1]?.type === 'ARROW') {
                        key = parseValue();
                        pos++;
                        isIndexedArray = false;
                    }
                    
                    const value = parseValue();
                    result[key] = value;
                    
                    if (isIndexedArray) index++;
                    if (tokens[pos]?.type === 'COMMA') pos++;
                }
                
                if (tokens[pos]?.type === 'RBRACKET' || tokens[pos]?.type === 'RPAREN') pos++;
                
                if (isIndexedArray) {
                    const arr = [];
                    for (let i = 0; i < index; i++) arr[i] = result[i];
                    return arr;
                }
                
                return result;
            }
            
            return parseValue();
        }

        // è½¬æ¢ä¸ºPHPæ ¼å¼
        function convertToPHP(obj, indent = 0) {
            const spaces = '    '.repeat(indent);
            const nextSpaces = '    '.repeat(indent + 1);
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return '[]';
                
                let result = '[\n';
                obj.forEach((item, index) => {
                    result += nextSpaces + convertToPHP(item, indent + 1);
                    if (index < obj.length - 1) result += ',';
                    result += '\n';
                });
                result += spaces + ']';
                return result;
            } else if (typeof obj === 'object' && obj !== null) {
                const keys = Object.keys(obj);
                if (keys.length === 0) return '[]';
                
                const isNumericKeys = keys.every(key => /^\d+$/.test(key));
                const isSequentialKeys = isNumericKeys && keys.map(Number).sort((a, b) => a - b).every((num, index) => num === index);
                
                let result = '[\n';
                keys.forEach((key, index) => {
                    let quotedKey;
                    if (isNumericKeys && isSequentialKeys) {
                        quotedKey = '';
                    } else if (/^\d+$/.test(key)) {
                        quotedKey = key + ' => ';
                    } else {
                        const escapedKey = key.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                        quotedKey = `'${escapedKey}' => `;
                    }
                    
                    result += nextSpaces + quotedKey + convertToPHP(obj[key], indent + 1);
                    if (index < keys.length - 1) result += ',';
                    result += '\n';
                });
                result += spaces + ']';
                return result;
            } else if (typeof obj === 'string') {
                const escaped = obj.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
                return `'${escaped}'`;
            } else if (typeof obj === 'boolean') {
                return obj ? 'true' : 'false';
            } else if (obj === null) {
                return 'null';
            } else if (typeof obj === 'number') {
                if (isNaN(obj)) return 'NAN';
                if (!isFinite(obj)) return obj > 0 ? 'INF' : '-INF';
                return obj.toString();
            } else {
                return obj.toString();
            }
        }

        // ==================== DDLè§£æåŠŸèƒ½ ====================
        
        function showDDLMessage(message, type = 'success') {
            const errorDiv = document.getElementById('ddlErrorMsg');
            const successDiv = document.getElementById('ddlSuccessMsg');
            
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';
            
            if (type === 'error') {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            } else {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
            }
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
            }, 3000);
        }

        function parseDDL() {
            const ddlInput = document.getElementById('ddlInput').value.trim();
            if (!ddlInput) {
                showDDLMessage('è¯·è¾“å…¥DDLè¯­å¥', 'error');
                return;
            }

            try {
                const result = parseDDLStatements(ddlInput);
                renderDDLResult(result);
                showDDLMessage('è§£ææˆåŠŸï¼');
            } catch (error) {
                console.error('DDLè§£æé”™è¯¯:', error);
                showDDLMessage('è§£æå¤±è´¥ï¼š' + error.message, 'error');
            }
        }

        function clearDDL() {
            document.getElementById('ddlInput').value = '';
            document.getElementById('ddlOutput').innerHTML = `
                <div class="ddl-placeholder">
                    <span>ğŸ“Š</span>
                    <p>è§£æç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                </div>
            `;
            document.getElementById('ddlErrorMsg').style.display = 'none';
            document.getElementById('ddlSuccessMsg').style.display = 'none';
        }

        // è§£æå¤šæ¡DDLè¯­å¥
        function parseDDLStatements(ddl) {
            // ç§»é™¤æ³¨é‡Š
            ddl = ddl.replace(/--.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
            
            const tables = {};
            const standaloneIndexes = [];
            
            // åˆ†å‰²è¯­å¥
            const statements = ddl.split(';').map(s => s.trim()).filter(s => s.length > 0);
            
            for (const stmt of statements) {
                // è§£æ CREATE TABLE
                if (/CREATE\s+TABLE/i.test(stmt)) {
                    const tableResult = parseCreateTable(stmt);
                    tables[tableResult.tableName.toLowerCase()] = tableResult;
                }
                // è§£æ CREATE INDEX
                else if (/CREATE\s+(UNIQUE\s+)?INDEX/i.test(stmt)) {
                    const indexResult = parseCreateIndex(stmt);
                    if (indexResult) {
                        const tableName = indexResult.tableName.toLowerCase();
                        if (tables[tableName]) {
                            // å°†ç´¢å¼•æ·»åŠ åˆ°å·²æœ‰çš„è¡¨ä¸­
                            tables[tableName].indexes.push(indexResult.index);
                            // æ›´æ–°å­—æ®µçš„ç´¢å¼•ä¿¡æ¯
                            for (const field of tables[tableName].fields) {
                                if (indexResult.index.columns.some(col => col.toLowerCase() === field.name.toLowerCase())) {
                                    field.indexes.push({
                                        name: indexResult.index.name,
                                        type: indexResult.index.type,
                                        isFirst: indexResult.index.columns[0].toLowerCase() === field.name.toLowerCase()
                                    });
                                }
                            }
                        } else {
                            // è¡¨ä¸å­˜åœ¨ï¼Œè®°å½•ä¸ºç‹¬ç«‹ç´¢å¼•
                            standaloneIndexes.push(indexResult);
                        }
                    }
                }
            }
            
            return {
                tables: Object.values(tables),
                standaloneIndexes
            };
        }

        // è§£æ CREATE TABLE è¯­å¥
        function parseCreateTable(ddl) {
            // æå–è¡¨å
            const tableNameMatch = ddl.match(/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?[`"']?(\w+)[`"']?/i);
            if (!tableNameMatch) {
                throw new Error('æ— æ³•è¯†åˆ«CREATE TABLEè¯­å¥');
            }
            const tableName = tableNameMatch[1];

            // æå–è¡¨æ³¨é‡Š
            const tableCommentMatch = ddl.match(/\)\s*[^;]*COMMENT\s*=?\s*['"]([^'"]+)['"]/i);
            const tableComment = tableCommentMatch ? tableCommentMatch[1] : '';

            // æå–æ‹¬å·å†…çš„å†…å®¹
            const contentMatch = ddl.match(/CREATE\s+TABLE[^(]*\(([\s\S]+)\)[^)]*$/i);
            if (!contentMatch) {
                throw new Error('æ— æ³•è§£æè¡¨å®šä¹‰å†…å®¹');
            }
            
            const content = contentMatch[1];
            const definitions = splitDefinitions(content);
            
            const fields = [];
            const indexes = [];
            
            for (const def of definitions) {
                const trimmedDef = def.trim();
                if (!trimmedDef) continue;
                
                if (/^(PRIMARY\s+KEY|UNIQUE\s+KEY|UNIQUE\s+INDEX|KEY|INDEX|FULLTEXT\s+KEY|FULLTEXT\s+INDEX|SPATIAL\s+KEY|SPATIAL\s+INDEX|CONSTRAINT)/i.test(trimmedDef)) {
                    const indexInfo = parseInlineIndex(trimmedDef);
                    if (indexInfo) indexes.push(indexInfo);
                } else if (/^[`"']?\w+[`"']?\s+/i.test(trimmedDef)) {
                    const fieldInfo = parseField(trimmedDef);
                    if (fieldInfo) fields.push(fieldInfo);
                }
            }
            
            // ä¸ºå­—æ®µæ·»åŠ ç´¢å¼•ä¿¡æ¯
            for (const field of fields) {
                field.indexes = [];
                for (const index of indexes) {
                    if (index.columns.some(col => col.toLowerCase() === field.name.toLowerCase())) {
                        field.indexes.push({
                            name: index.name,
                            type: index.type,
                            isFirst: index.columns[0].toLowerCase() === field.name.toLowerCase()
                        });
                    }
                }
            }
            
            return { tableName, tableComment, fields, indexes };
        }

        // è§£æ CREATE INDEX è¯­å¥
        function parseCreateIndex(stmt) {
            // CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON table_name (column_list)
            const match = stmt.match(/CREATE\s+(UNIQUE\s+|FULLTEXT\s+|SPATIAL\s+)?INDEX\s+[`"']?(\w+)[`"']?\s+ON\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
            
            if (!match) return null;
            
            const typeStr = (match[1] || '').trim().toUpperCase();
            let type = 'INDEX';
            if (typeStr === 'UNIQUE') type = 'UNIQUE';
            else if (typeStr === 'FULLTEXT') type = 'FULLTEXT';
            else if (typeStr === 'SPATIAL') type = 'SPATIAL';
            
            const name = match[2];
            const tableName = match[3];
            const columns = parseIndexColumns(match[4]);
            
            return {
                tableName,
                index: { type, name, columns }
            };
        }

        // åˆ†å‰²å®šä¹‰ï¼ˆå¤„ç†æ‹¬å·åµŒå¥—ï¼‰
        function splitDefinitions(content) {
            const definitions = [];
            let current = '';
            let depth = 0;
            let inString = false;
            let stringChar = '';
            
            for (let i = 0; i < content.length; i++) {
                const char = content[i];
                
                if (inString) {
                    current += char;
                    if (char === stringChar && content[i - 1] !== '\\') {
                        inString = false;
                    }
                    continue;
                }
                
                if (char === "'" || char === '"' || char === '`') {
                    inString = true;
                    stringChar = char;
                    current += char;
                    continue;
                }
                
                if (char === '(') { depth++; current += char; continue; }
                if (char === ')') { depth--; current += char; continue; }
                
                if (char === ',' && depth === 0) {
                    definitions.push(current.trim());
                    current = '';
                    continue;
                }
                
                current += char;
            }
            
            if (current.trim()) definitions.push(current.trim());
            return definitions;
        }

        // è§£æå­—æ®µ
        function parseField(fieldDef) {
            const nameMatch = fieldDef.match(/^[`"']?(\w+)[`"']?\s+(.+)$/i);
            if (!nameMatch) return null;
            
            const name = nameMatch[1];
            const rest = nameMatch[2];
            
            const typeMatch = rest.match(/^(\w+(?:\s*\([^)]+\))?(?:\s+unsigned)?(?:\s+zerofill)?)/i);
            const type = typeMatch ? typeMatch[1].trim() : 'UNKNOWN';
            
            const nullable = !/\bNOT\s+NULL\b/i.test(rest);
            
            let defaultValue = null;
            const defaultMatch = rest.match(/DEFAULT\s+('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|[\w()]+)/i);
            if (defaultMatch) {
                defaultValue = defaultMatch[1].replace(/^['"]|['"]$/g, '');
            }
            
            const autoIncrement = /\bAUTO_INCREMENT\b/i.test(rest);
            
            let comment = '';
            const commentMatch = rest.match(/COMMENT\s+['"]([^'"]*)['"]/i);
            if (commentMatch) comment = commentMatch[1];
            
            const isPrimaryKey = /\bPRIMARY\s+KEY\b/i.test(rest);
            
            return { name, type, nullable, defaultValue, autoIncrement, comment, isPrimaryKey, indexes: [] };
        }

        // è§£æå†…è”ç´¢å¼•ï¼ˆCREATE TABLE å†…çš„ç´¢å¼•å®šä¹‰ï¼‰
        function parseInlineIndex(indexDef) {
            let type = 'INDEX';
            let name = '';
            let columns = [];
            
            if (/^PRIMARY\s+KEY/i.test(indexDef)) {
                type = 'PRIMARY';
                name = 'PRIMARY';
                const colMatch = indexDef.match(/\(([^)]+)\)/);
                if (colMatch) columns = parseIndexColumns(colMatch[1]);
            }
            else if (/^UNIQUE\s+(KEY|INDEX)/i.test(indexDef)) {
                type = 'UNIQUE';
                const nameMatch = indexDef.match(/^UNIQUE\s+(?:KEY|INDEX)\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
                if (nameMatch) {
                    name = nameMatch[1];
                    columns = parseIndexColumns(nameMatch[2]);
                }
            }
            else if (/^FULLTEXT\s+(KEY|INDEX)/i.test(indexDef)) {
                type = 'FULLTEXT';
                const nameMatch = indexDef.match(/^FULLTEXT\s+(?:KEY|INDEX)\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
                if (nameMatch) {
                    name = nameMatch[1];
                    columns = parseIndexColumns(nameMatch[2]);
                }
            }
            else if (/^(KEY|INDEX)/i.test(indexDef)) {
                type = 'INDEX';
                const nameMatch = indexDef.match(/^(?:KEY|INDEX)\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
                if (nameMatch) {
                    name = nameMatch[1];
                    columns = parseIndexColumns(nameMatch[2]);
                }
            }
            
            if (columns.length === 0) return null;
            return { type, name, columns };
        }

        // è§£æç´¢å¼•åˆ—
        function parseIndexColumns(columnsStr) {
            return columnsStr.split(',').map(col => {
                const match = col.trim().match(/[`"']?(\w+)[`"']?/);
                return match ? match[1] : '';
            }).filter(Boolean);
        }

        // æ¸²æŸ“DDLç»“æœ
        function renderDDLResult(result) {
            const output = document.getElementById('ddlOutput');
            let html = '';
            
            // æ¸²æŸ“æ¯ä¸ªè¡¨
            for (const table of result.tables) {
                html += renderTableResult(table);
            }
            
            // æ¸²æŸ“ç‹¬ç«‹ç´¢å¼•
            if (result.standaloneIndexes.length > 0) {
                html += `
                    <div class="index-section">
                        <h5>ğŸ”— ç‹¬ç«‹ç´¢å¼•ï¼ˆæœªæ‰¾åˆ°å¯¹åº”è¡¨ï¼‰</h5>
                        <div class="index-list">
                `;
                
                for (const item of result.standaloneIndexes) {
                    const badgeClass = getIndexBadgeClass(item.index.type);
                    html += `
                        <div class="index-item">
                            <span class="index-badge ${badgeClass}">${getIndexTypeLabel(item.index.type)}</span>
                            <span class="index-name">${escapeHtml(item.index.name)}</span>
                            <span class="index-table">ON ${escapeHtml(item.tableName)}</span>
                            <span class="index-columns">(${item.index.columns.map(c => escapeHtml(c)).join(', ')})</span>
                        </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            if (!html) {
                html = `
                    <div class="ddl-placeholder">
                        <span>âš ï¸</span>
                        <p>æœªèƒ½è§£æå‡ºæœ‰æ•ˆçš„DDLè¯­å¥</p>
                    </div>
                `;
            }
            
            output.innerHTML = html;
        }

        // æ¸²æŸ“å•ä¸ªè¡¨çš„ç»“æœ
        function renderTableResult(table) {
            let html = `
                <div class="table-info">
                    <h4>
                        ğŸ“‹ è¡¨å: <span class="table-name">${escapeHtml(table.tableName)}</span>
                        ${table.tableComment ? `<span class="table-comment">ï¼ˆ${escapeHtml(table.tableComment)}ï¼‰</span>` : ''}
                    </h4>
                </div>
                
                <table class="ddl-table">
                    <thead>
                        <tr>
                            <th>å­—æ®µå</th>
                            <th>ç±»å‹</th>
                            <th>å…è®¸NULL</th>
                            <th>é»˜è®¤å€¼</th>
                            <th>ç´¢å¼•</th>
                            <th>æ³¨é‡Š</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const field of table.fields) {
                const indexBadges = renderIndexBadges(field);
                
                html += `
                    <tr>
                        <td class="field-name">${escapeHtml(field.name)}${field.autoIncrement ? ' <small style="color:#999">(AI)</small>' : ''}</td>
                        <td class="field-type">${escapeHtml(field.type)}</td>
                        <td class="field-nullable ${field.nullable ? 'nullable-yes' : 'nullable-no'}">${field.nullable ? 'âœ“' : 'âœ—'}</td>
                        <td class="field-default">${field.defaultValue !== null ? escapeHtml(field.defaultValue) : '<span style="color:#999">-</span>'}</td>
                        <td class="index-badges">${indexBadges || '<span style="color:#999">-</span>'}</td>
                        <td class="field-comment">${escapeHtml(field.comment) || '<span style="color:#999">-</span>'}</td>
                    </tr>
                `;
            }
            
            html += '</tbody></table>';
            
            // æ·»åŠ ç´¢å¼•åˆ—è¡¨
            if (table.indexes.length > 0) {
                html += `
                    <div class="index-section">
                        <h5>ğŸ”‘ ç´¢å¼•åˆ—è¡¨</h5>
                        <div class="index-list">
                `;
                
                for (const index of table.indexes) {
                    const badgeClass = getIndexBadgeClass(index.type);
                    html += `
                        <div class="index-item">
                            <span class="index-badge ${badgeClass}">${getIndexTypeLabel(index.type)}</span>
                            <span class="index-name">${escapeHtml(index.name)}</span>
                            <span class="index-columns">(${index.columns.map(c => escapeHtml(c)).join(', ')})</span>
                        </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            return html;
        }

        // æ¸²æŸ“ç´¢å¼•å¾½ç« 
        function renderIndexBadges(field) {
            if (field.indexes.length === 0 && !field.isPrimaryKey) return '';
            
            let badges = '';
            
            if (field.isPrimaryKey) {
                badges += `<span class="index-badge index-primary">ğŸ”‘ ä¸»é”®</span>`;
            }
            
            for (const idx of field.indexes) {
                if (idx.type === 'PRIMARY' && field.isPrimaryKey) continue;
                
                const badgeClass = getIndexBadgeClass(idx.type);
                const label = getIndexTypeLabel(idx.type);
                const prefix = idx.isFirst ? '' : 'â†³ ';
                
                badges += `<span class="index-badge ${badgeClass}" title="${escapeHtml(idx.name)}">${prefix}${label}</span>`;
            }
            
            return badges;
        }

        function getIndexBadgeClass(type) {
            switch (type) {
                case 'PRIMARY': return 'index-primary';
                case 'UNIQUE': return 'index-unique';
                case 'FULLTEXT': return 'index-fulltext';
                default: return 'index-normal';
            }
        }

        function getIndexTypeLabel(type) {
            switch (type) {
                case 'PRIMARY': return 'ğŸ”‘ ä¸»é”®';
                case 'UNIQUE': return 'ğŸ¯ å”¯ä¸€';
                case 'FULLTEXT': return 'ğŸ“ å…¨æ–‡';
                default: return 'ğŸ“‡ ç´¢å¼•';
            }
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // å¤åˆ¶ä¸ºMarkdownè¡¨æ ¼
        function copyTableAsMarkdown() {
            const ddlInput = document.getElementById('ddlInput').value.trim();
            if (!ddlInput) {
                showDDLMessage('è¯·å…ˆè¾“å…¥å¹¶è§£æDDLè¯­å¥', 'error');
                return;
            }

            try {
                const result = parseDDLStatements(ddlInput);
                const markdown = generateMarkdownTable(result);
                
                navigator.clipboard.writeText(markdown).then(() => {
                    showDDLMessage('å·²å¤åˆ¶Markdownåˆ°å‰ªè´´æ¿ï¼');
                }).catch(err => {
                    const textarea = document.createElement('textarea');
                    textarea.value = markdown;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showDDLMessage('å·²å¤åˆ¶Markdownåˆ°å‰ªè´´æ¿ï¼');
                });
            } catch (error) {
                showDDLMessage('å¤åˆ¶å¤±è´¥ï¼š' + error.message, 'error');
            }
        }

        function generateMarkdownTable(result) {
            let md = '';
            
            for (const table of result.tables) {
                md += `## è¡¨å: ${table.tableName}`;
                if (table.tableComment) md += ` (${table.tableComment})`;
                md += '\n\n';
                
                md += '| å­—æ®µå | ç±»å‹ | å…è®¸NULL | é»˜è®¤å€¼ | ç´¢å¼• | æ³¨é‡Š |\n';
                md += '|--------|------|----------|--------|------|------|\n';
                
                for (const field of table.fields) {
                    const indexLabels = [];
                    if (field.isPrimaryKey) indexLabels.push('ä¸»é”®');
                    for (const idx of field.indexes) {
                        if (idx.type === 'PRIMARY' && field.isPrimaryKey) continue;
                        indexLabels.push(`${getIndexTypeText(idx.type)}(${idx.name})`);
                    }
                    
                    md += `| ${field.name}${field.autoIncrement ? ' (AI)' : ''} `;
                    md += `| ${field.type} `;
                    md += `| ${field.nullable ? 'æ˜¯' : 'å¦'} `;
                    md += `| ${field.defaultValue !== null ? field.defaultValue : '-'} `;
                    md += `| ${indexLabels.length > 0 ? indexLabels.join(', ') : '-'} `;
                    md += `| ${field.comment || '-'} |\n`;
                }
                
                if (table.indexes.length > 0) {
                    md += '\n### ç´¢å¼•åˆ—è¡¨\n\n';
                    md += '| ç´¢å¼•å | ç±»å‹ | å­—æ®µ |\n';
                    md += '|--------|------|------|\n';
                    
                    for (const index of table.indexes) {
                        md += `| ${index.name} | ${getIndexTypeText(index.type)} | ${index.columns.join(', ')} |\n`;
                    }
                }
                
                md += '\n';
            }
            
            return md;
        }

        function getIndexTypeText(type) {
            switch (type) {
                case 'PRIMARY': return 'ä¸»é”®';
                case 'UNIQUE': return 'å”¯ä¸€ç´¢å¼•';
                case 'FULLTEXT': return 'å…¨æ–‡ç´¢å¼•';
                default: return 'æ™®é€šç´¢å¼•';
            }
        }
    </script>
</body>
</html>
