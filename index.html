<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¼€å‘å·¥å…·ç®±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            padding: 20px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 5px;
            font-weight: 300;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            flex: 1;
            overflow: hidden;
        }

        .tool-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .tool-title {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            text-align: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .tool-icon {
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .converter-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
            flex: 1;
            overflow: hidden;
        }

        .converter-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .converter-section h3 {
            font-size: 1rem;
            color: #555;
            margin-bottom: 10px;
            text-align: center;
            padding: 8px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 8px;
            font-weight: 500;
            flex-shrink: 0;
        }

        textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            transition: border-color 0.3s ease;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-section {
            grid-column: 1 / -1;
            text-align: center;
            flex-shrink: 0;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e1e8ed;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .error {
            background: #fff5f5;
            color: #e53e3e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #e53e3e;
            display: none;
        }

        .success {
            background: #f0fff4;
            color: #38a169;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #38a169;
            display: none;
        }


        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .tools-grid {
                grid-template-columns: 1fr;
            }
            
            .converter-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                min-width: auto;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .tool-card {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ› ï¸ å¼€å‘å·¥å…·ç®±</h1>
            <p>å®ç”¨çš„å¼€å‘å°å·¥å…·é›†åˆ</p>
        </div>

        <div class="tools-grid">
            <!-- PHPæ•°ç»„ä¸JSONè½¬æ¢å·¥å…· -->
            <div class="tool-card">
                <div class="tool-title">
                    <div class="tool-icon">ğŸ”„</div>
                    PHPæ•°ç»„ â‡„ JSON è½¬æ¢å™¨
                </div>

                <div class="converter-container">
                    <div class="converter-section">
                        <h3>PHPæ•°ç»„æ ¼å¼</h3>
                        <textarea id="phpInput" placeholder="è¯·è¾“å…¥PHPæ•°ç»„æ ¼å¼ï¼Œä¾‹å¦‚ï¼š
array(
    'name' => 'å¼ ä¸‰',
    'age' => 25,
    'skills' => array('PHP', 'JavaScript', 'Python')
)

æˆ–è€…ç®€åŒ–æ ¼å¼ï¼š
[
    'name' => 'å¼ ä¸‰',
    'age' => 25,
    'skills' => ['PHP', 'JavaScript', 'Python']
]"></textarea>
                    </div>

                    <div class="converter-section">
                        <h3>JSONæ ¼å¼</h3>
                        <textarea id="jsonInput" placeholder="è¯·è¾“å…¥JSONæ ¼å¼ï¼Œä¾‹å¦‚ï¼š
{
    &quot;name&quot;: &quot;å¼ ä¸‰&quot;,
    &quot;age&quot;: 25,
    &quot;skills&quot;: [&quot;PHP&quot;, &quot;JavaScript&quot;, &quot;Python&quot;]
}"></textarea>
                    </div>
                </div>

                <div class="control-section">
                    <div class="buttons">
                        <button class="btn btn-primary" onclick="phpToJson()">PHP â†’ JSON</button>
                        <button class="btn btn-primary" onclick="jsonToPhp()">JSON â†’ PHP</button>
                        <button class="btn btn-secondary" onclick="clearAll()">æ¸…ç©º</button>
                    </div>

                    <div class="error" id="errorMsg"></div>
                    <div class="success" id="successMsg"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(message, type = 'success') {
            const errorDiv = document.getElementById('errorMsg');
            const successDiv = document.getElementById('successMsg');
            
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';
            
            if (type === 'error') {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            } else {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
            }
            
            // 3ç§’åè‡ªåŠ¨éšè—
            setTimeout(() => {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
            }, 3000);
        }

        // PHPè½¬JSON
        function phpToJson() {
            const phpInput = document.getElementById('phpInput').value.trim();
            if (!phpInput) {
                showMessage('è¯·è¾“å…¥PHPæ•°ç»„æ ¼å¼', 'error');
                return;
            }

            try {
                // é¦–å…ˆå°è¯•æ™ºèƒ½è§£æå™¨
                let jsonResult;
                try {
                    jsonResult = smartParsePHPArray(phpInput);
                    console.log('ä½¿ç”¨æ™ºèƒ½è§£æå™¨æˆåŠŸ');
                } catch (smartError) {
                    console.log('æ™ºèƒ½è§£æå™¨å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€è§£æå™¨:', smartError.message);
                    jsonResult = parsePHPArray(phpInput);
                }
                
                document.getElementById('jsonInput').value = JSON.stringify(jsonResult, null, 2);
                showMessage('è½¬æ¢æˆåŠŸï¼');
            } catch (error) {
                console.error('æ‰€æœ‰è§£æå™¨éƒ½å¤±è´¥äº†:', error);
                showMessage('è½¬æ¢å¤±è´¥ï¼š' + error.message, 'error');
            }
        }

        // JSONè½¬PHP
        function jsonToPhp() {
            const jsonInput = document.getElementById('jsonInput').value.trim();
            if (!jsonInput) {
                showMessage('è¯·è¾“å…¥JSONæ ¼å¼', 'error');
                return;
            }

            try {
                const jsonObj = JSON.parse(jsonInput);
                const phpResult = convertToPHP(jsonObj);
                document.getElementById('phpInput').value = phpResult;
                showMessage('è½¬æ¢æˆåŠŸï¼');
            } catch (error) {
                showMessage('è½¬æ¢å¤±è´¥ï¼šè¯·æ£€æŸ¥JSONæ ¼å¼æ˜¯å¦æ­£ç¡®', 'error');
            }
        }

        // æ¸…ç©ºæ‰€æœ‰è¾“å…¥
        function clearAll() {
            document.getElementById('phpInput').value = '';
            document.getElementById('jsonInput').value = '';
            document.getElementById('errorMsg').style.display = 'none';
            document.getElementById('successMsg').style.display = 'none';
        }

        // è§£æPHPæ•°ç»„ - å¢å¼ºç‰ˆ
        function parsePHPArray(phpString) {
            try {
                // ç§»é™¤PHPæ ‡ç­¾å’Œå¤šä½™ç©ºæ ¼
                let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
                
                // ç§»é™¤å˜é‡å£°æ˜ï¼ˆå¦‚ $array = ï¼‰
                cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
                
                // ç§»é™¤å°¾éšåˆ†å·
                cleanString = cleanString.replace(/;$/, '');
                
                // å¤„ç†array()è¯­æ³•ï¼Œæ”¯æŒåµŒå¥—
                cleanString = replaceArraySyntax(cleanString);
                
                // å¤„ç†PHPçš„å…³è”æ•°ç»„è¯­æ³• => è½¬ä¸º :
                cleanString = replaceArrowSyntax(cleanString);
                
                // æ›¿æ¢PHPçš„å•å¼•å·ä¸ºåŒå¼•å·ï¼Œå¤„ç†è½¬ä¹‰
                cleanString = replaceSingleQuotes(cleanString);
                
                // å¤„ç†PHPç‰¹æ®Šå€¼
                cleanString = replacePhpValues(cleanString);
                
                // ä¿®å¤é”®åæ ¼å¼
                cleanString = fixKeyFormat(cleanString);
                
                // æœ€ç»ˆæ¸…ç†
                cleanString = cleanString.trim();
                
                console.log('æ¸…ç†åçš„å­—ç¬¦ä¸²:', cleanString); // è°ƒè¯•ä¿¡æ¯
                
                return JSON.parse(cleanString);
            } catch (error) {
                console.error('è§£æé”™è¯¯:', error.message);
                console.error('æ¸…ç†åçš„å­—ç¬¦ä¸²:', cleanString);
                throw new Error('PHPæ•°ç»„æ ¼å¼è§£æå¤±è´¥ï¼š' + error.message + '\nè¯·æ£€æŸ¥è¯­æ³•æ˜¯å¦æ­£ç¡®');
            }
        }
        
        // é€’å½’æ›¿æ¢array()è¯­æ³•
        function replaceArraySyntax(str) {
            let result = str;
            let changed = true;
            
            while (changed) {
                const before = result;
                result = result.replace(/\barray\s*\(/g, '[');
                changed = before !== result;
            }
            
            // å¹³è¡¡æ‹¬å·
            result = balanceParentheses(result);
            
            return result;
        }
        
        // å¹³è¡¡æ‹¬å·è½¬æ¢
        function balanceParentheses(str) {
            let result = '';
            let depth = 0;
            let inString = false;
            let stringChar = '';
            let escaped = false;
            
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                
                if (escaped) {
                    result += char;
                    escaped = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escaped = true;
                    continue;
                }
                
                if (!inString && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (inString && char === stringChar) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    result += char;
                    continue;
                }
                
                if (char === '(') {
                    depth++;
                    result += '[';
                } else if (char === ')') {
                    depth--;
                    result += ']';
                } else {
                    result += char;
                }
            }
            
            return result;
        }
        
        // æ›¿æ¢ç®­å¤´è¯­æ³• - æ”¹è¿›ç‰ˆ
        function replaceArrowSyntax(str) {
            // æ›´ç²¾ç¡®çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¤„ç†å„ç§é”®ç±»å‹å’ŒåµŒå¥—ç»“æ„
            return str.replace(/((?:'[^'\\]*(?:\\.[^'\\]*)*'|"[^"\\]*(?:\\.[^"\\]*)*"|\w+|\d+))\s*=>\s*/g, function(match, key) {
                // æ•°å­—é”®ä¸éœ€è¦å¼•å·
                if (/^\d+$/.test(key)) {
                    return key + ': ';
                }
                // å·²ç»æœ‰å¼•å·çš„ä¿æŒåŸæ ·
                if (key.match(/^['"]/)) {
                    return key + ': ';
                }
                // å…¶ä»–æƒ…å†µæ·»åŠ åŒå¼•å·
                return '"' + key + '": ';
            });
        }
        
        // ä¿®å¤é”®åæ ¼å¼
        function fixKeyFormat(str) {
            // å¤„ç†æ²¡æœ‰å¼•å·çš„å­—ç¬¦ä¸²é”®å
            return str.replace(/(\w+)(\s*:\s*)/g, function(match, key, colon) {
                // å¦‚æœé”®åä¸æ˜¯æ•°å­—ä¸”æ²¡æœ‰å¼•å·ï¼Œæ·»åŠ åŒå¼•å·
                if (!/^\d+$/.test(key) && !key.match(/^['"]/)) {
                    return '"' + key + '"' + colon;
                }
                return match;
            });
        }
        
        // æ›¿æ¢å•å¼•å·ä¸ºåŒå¼•å·
        function replaceSingleQuotes(str) {
            let result = '';
            let inDoubleQuote = false;
            let escaped = false;
            
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                
                if (escaped) {
                    result += char;
                    escaped = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escaped = true;
                    continue;
                }
                
                if (char === '"') {
                    inDoubleQuote = !inDoubleQuote;
                    result += char;
                    continue;
                }
                
                if (inDoubleQuote) {
                    result += char;
                    continue;
                }
                
                if (char === "'") {
                    result += '"';
                } else {
                    result += char;
                }
            }
            
            return result;
        }
        
        // æ›¿æ¢PHPç‰¹æ®Šå€¼
        function replacePhpValues(str) {
            // ä¸åœ¨å­—ç¬¦ä¸²å†…çš„PHPå€¼æ›¿æ¢
            let result = str.replace(/\b(true|false|null|TRUE|FALSE|NULL)\b/g, function(match) {
                return match.toLowerCase();
            });
            
            // å¤„ç†PHPç‰¹æ®Šæ•°å€¼
            result = result.replace(/\bINF\b/g, '"Infinity"');
            result = result.replace(/\bNAN\b/g, '"NaN"');
            result = result.replace(/\b-INF\b/g, '"-Infinity"');
            
            return result;
        }
        
        // æ™ºèƒ½PHPæ•°ç»„è§£æå™¨ - å¤„ç†å¤æ‚åµŒå¥—ç»“æ„
        function smartParsePHPArray(phpString) {
            try {
                // é¢„å¤„ç†
                let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
                cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
                cleanString = cleanString.replace(/;$/, '');
                
                // ä½¿ç”¨çŠ¶æ€æœºè§£æ
                const tokens = tokenize(cleanString);
                const ast = parseTokens(tokens);
                return ast;
            } catch (error) {
                console.error('æ™ºèƒ½è§£æå¤±è´¥ï¼Œå›é€€åˆ°åŸºç¡€è§£æå™¨:', error);
                // å›é€€åˆ°åŸå§‹è§£ææ–¹æ³•
                return parsePHPArrayFallback(phpString);
            }
        }
        
        // è¯æ³•åˆ†æ
        function tokenize(str) {
            const tokens = [];
            let i = 0;
            
            while (i < str.length) {
                const char = str[i];
                
                if (/\s/.test(char)) {
                    i++;
                    continue;
                }
                
                // å­—ç¬¦ä¸²
                if (char === '"' || char === "'") {
                    const quote = char;
                    let value = '';
                    i++;
                    while (i < str.length && str[i] !== quote) {
                        if (str[i] === '\\' && i + 1 < str.length) {
                            value += str[i] + str[i + 1];
                            i += 2;
                        } else {
                            value += str[i];
                            i++;
                        }
                    }
                    tokens.push({type: 'STRING', value: value, quote: quote});
                    i++;
                    continue;
                }
                
                // æ•°å­—
                if (/\d/.test(char) || (char === '-' && /\d/.test(str[i + 1]))) {
                    let value = '';
                    if (char === '-') {
                        value += char;
                        i++;
                    }
                    while (i < str.length && /[\d.]/.test(str[i])) {
                        value += str[i];
                        i++;
                    }
                    tokens.push({type: 'NUMBER', value: parseFloat(value)});
                    continue;
                }
                
                // å…³é”®å­—å’Œæ ‡è¯†ç¬¦
                if (/[a-zA-Z_]/.test(char)) {
                    let value = '';
                    while (i < str.length && /[a-zA-Z0-9_]/.test(str[i])) {
                        value += str[i];
                        i++;
                    }
                    
                    if (value === 'array') {
                        tokens.push({type: 'ARRAY'});
                    } else if (['true', 'false', 'null'].includes(value.toLowerCase())) {
                        tokens.push({type: 'LITERAL', value: value.toLowerCase()});
                    } else {
                        tokens.push({type: 'IDENTIFIER', value: value});
                    }
                    continue;
                }
                
                // ç¬¦å·
                if (char === '=' && str[i + 1] === '>') {
                    tokens.push({type: 'ARROW'});
                    i += 2;
                    continue;
                }
                
                // å•å­—ç¬¦ç¬¦å·
                const singleChars = {
                    '[': 'LBRACKET',
                    ']': 'RBRACKET',
                    '(': 'LPAREN',
                    ')': 'RPAREN',
                    ',': 'COMMA'
                };
                
                if (singleChars[char]) {
                    tokens.push({type: singleChars[char]});
                    i++;
                    continue;
                }
                
                i++;
            }
            
            return tokens;
        }
        
        // è¯­æ³•åˆ†æ
        function parseTokens(tokens) {
            let pos = 0;
            
            function parseValue() {
                const token = tokens[pos];
                
                if (!token) {
                    throw new Error('æ„å¤–çš„è¾“å…¥ç»“æŸ');
                }
                
                if (token.type === 'STRING') {
                    pos++;
                    return token.value;
                }
                
                if (token.type === 'NUMBER') {
                    pos++;
                    return token.value;
                }
                
                if (token.type === 'LITERAL') {
                    pos++;
                    return token.value === 'true' ? true : 
                           token.value === 'false' ? false : null;
                }
                
                if (token.type === 'LBRACKET' || token.type === 'ARRAY') {
                    return parseArray();
                }
                
                throw new Error('æ— æ³•è§£æçš„å€¼: ' + JSON.stringify(token));
            }
            
            function parseArray() {
                const result = {};
                let isIndexedArray = true;
                let index = 0;
                
                // è·³è¿‡ 'array' å…³é”®å­—æˆ– '['
                if (tokens[pos]?.type === 'ARRAY') {
                    pos++;
                    if (tokens[pos]?.type === 'LPAREN') pos++;
                } else if (tokens[pos]?.type === 'LBRACKET') {
                    pos++;
                }
                
                while (pos < tokens.length && 
                       tokens[pos]?.type !== 'RBRACKET' && 
                       tokens[pos]?.type !== 'RPAREN') {
                    
                    let key = index;
                    let value;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰é”®
                    if (pos + 1 < tokens.length && tokens[pos + 1]?.type === 'ARROW') {
                        key = parseValue();
                        pos++; // è·³è¿‡ '=>'
                        isIndexedArray = false;
                    }
                    
                    value = parseValue();
                    result[key] = value;
                    
                    if (isIndexedArray) index++;
                    
                    // è·³è¿‡é€—å·
                    if (tokens[pos]?.type === 'COMMA') {
                        pos++;
                    }
                }
                
                // è·³è¿‡ç»“æŸç¬¦å·
                if (tokens[pos]?.type === 'RBRACKET' || tokens[pos]?.type === 'RPAREN') {
                    pos++;
                }
                
                // å¦‚æœæ˜¯çº¯ç´¢å¼•æ•°ç»„ï¼Œè½¬æ¢ä¸ºæ•°ç»„
                if (isIndexedArray) {
                    const arr = [];
                    for (let i = 0; i < index; i++) {
                        arr[i] = result[i];
                    }
                    return arr;
                }
                
                return result;
            }
            
            return parseValue();
        }
        
        // å¤‡ç”¨è§£æå™¨
        function parsePHPArrayFallback(phpString) {
            let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
            cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
            cleanString = cleanString.replace(/;$/, '');
            cleanString = replaceArraySyntax(cleanString);
            cleanString = replaceArrowSyntax(cleanString);
            cleanString = replaceSingleQuotes(cleanString);
            cleanString = replacePhpValues(cleanString);
            cleanString = fixKeyFormat(cleanString);
            return JSON.parse(cleanString);
        }

        // è½¬æ¢ä¸ºPHPæ ¼å¼ - å¢å¼ºç‰ˆ
        function convertToPHP(obj, indent = 0, isRoot = false) {
            const spaces = '    '.repeat(indent);
            const nextSpaces = '    '.repeat(indent + 1);
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return '[]';
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºç´¢å¼•æ•°ç»„
                const isIndexedArray = obj.every((item, index) => true);
                
                let result = '[\n';
                obj.forEach((item, index) => {
                    result += nextSpaces + convertToPHP(item, indent + 1);
                    if (index < obj.length - 1) result += ',';
                    result += '\n';
                });
                result += spaces + ']';
                return result;
            } else if (typeof obj === 'object' && obj !== null) {
                const keys = Object.keys(obj);
                if (keys.length === 0) return '[]';
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºçº¯æ•°å­—ç´¢å¼•çš„å¯¹è±¡
                const isNumericKeys = keys.every(key => /^\d+$/.test(key));
                const isSequentialKeys = isNumericKeys && keys.length > 0 && 
                    keys.map(Number).sort((a, b) => a - b).every((num, index) => num === index);
                
                let result = '[\n';
                keys.forEach((key, index) => {
                    let quotedKey;
                    if (isNumericKeys && isSequentialKeys) {
                        // è¿ç»­æ•°å­—ç´¢å¼•ï¼Œå¯ä»¥çœç•¥é”®
                        quotedKey = '';
                    } else if (/^\d+$/.test(key)) {
                        // æ•°å­—é”®
                        quotedKey = key + ' => ';
                    } else {
                        // å­—ç¬¦ä¸²é”®ï¼Œè½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
                        const escapedKey = key.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                        quotedKey = `'${escapedKey}' => `;
                    }
                    
                    result += nextSpaces + quotedKey + convertToPHP(obj[key], indent + 1);
                    if (index < keys.length - 1) result += ',';
                    result += '\n';
                });
                result += spaces + ']';
                return result;
            } else if (typeof obj === 'string') {
                // æ›´å¥½çš„å­—ç¬¦ä¸²è½¬ä¹‰å¤„ç†
                const escaped = obj
                    .replace(/\\/g, '\\\\')  // åæ–œæ 
                    .replace(/'/g, "\\'")    // å•å¼•å·
                    .replace(/\n/g, '\\n')   // æ¢è¡Œç¬¦
                    .replace(/\r/g, '\\r')   // å›è½¦ç¬¦
                    .replace(/\t/g, '\\t');  // åˆ¶è¡¨ç¬¦
                return `'${escaped}'`;
            } else if (typeof obj === 'boolean') {
                return obj ? 'true' : 'false';
            } else if (obj === null) {
                return 'null';
            } else if (typeof obj === 'number') {
                // å¤„ç†ç‰¹æ®Šæ•°å­—å€¼
                if (isNaN(obj)) return 'NAN';
                if (!isFinite(obj)) return obj > 0 ? 'INF' : '-INF';
                return obj.toString();
            } else {
                return obj.toString();
            }
        }

    </script>
</body>
</html>
