<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂºÄÂèëÂ∑•ÂÖ∑ÁÆ±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* ÂØºËà™ËèúÂçïÊ†∑Âºè */
        .nav-bar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            padding: 0 20px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            height: 60px;
        }

        .nav-logo {
            font-size: 1.3rem;
            font-weight: 600;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 40px;
            cursor: pointer;
        }

        .nav-logo:hover {
            color: #764ba2;
        }

        .nav-menu {
            display: flex;
            gap: 5px;
            list-style: none;
        }

        .nav-item {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            color: #555;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-item:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .nav-item.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .nav-item .nav-icon {
            font-size: 16px;
        }

        /* ‰∏ªÂÜÖÂÆπÂå∫Âüü */
        .main-content {
            flex: 1;
            padding: 30px 20px;
            overflow-y: auto;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Â∑•ÂÖ∑È°µÈù¢ */
        .tool-page {
            display: none;
        }

        .tool-page.active {
            display: block;
        }

        /* È¶ñÈ°µÊ†∑Âºè */
        .home-header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .home-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .home-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }

        .tool-card-home {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .tool-card-home:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .tool-card-home .card-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-bottom: 15px;
        }

        .tool-card-home h3 {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 8px;
        }

        .tool-card-home p {
            color: #666;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Â∑•ÂÖ∑Âç°ÁâáÈÄöÁî®Ê†∑Âºè */
        .tool-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .tool-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .tool-header .icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .tool-header h2 {
            font-size: 1.4rem;
            color: #333;
            font-weight: 600;
        }

        /* ËΩ¨Êç¢Âô®Â∏ÉÂ±Ä */
        .converter-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .converter-section {
            display: flex;
            flex-direction: column;
        }

        .converter-section h3 {
            font-size: 0.95rem;
            color: white;
            margin-bottom: 10px;
            padding: 10px 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .control-section {
            margin-top: 20px;
            text-align: center;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e1e8ed;
        }

        .btn-secondary:hover {
            background: #e9ecef;
        }

        .message {
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .message.error {
            background: #fff5f5;
            color: #e53e3e;
            border-left: 4px solid #e53e3e;
        }

        .message.success {
            background: #f0fff4;
            color: #38a169;
            border-left: 4px solid #38a169;
        }

        /* DDLËß£ÊûêÂô®Ê†∑Âºè */
        .ddl-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .ddl-input-section {
            display: flex;
            flex-direction: column;
        }

        .ddl-input-section h3 {
            font-size: 0.95rem;
            color: white;
            margin-bottom: 10px;
            padding: 10px 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        .ddl-control-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ddl-control-section .buttons {
            flex-direction: column;
        }

        .ddl-output-section {
            grid-column: 1 / -1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            min-height: 200px;
        }

        .ddl-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 150px;
            color: #999;
        }

        .ddl-placeholder span {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .table-info {
            margin-bottom: 20px;
        }

        .table-info h4 {
            font-size: 1.1rem;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .table-info .table-name {
            color: #667eea;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .table-info .table-comment {
            color: #666;
            font-size: 0.9rem;
        }

        .ddl-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .ddl-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: 500;
            white-space: nowrap;
        }

        .ddl-table td {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            vertical-align: top;
        }

        .ddl-table tr:last-child td {
            border-bottom: none;
        }

        .ddl-table tr:hover {
            background: #f8f9fa;
        }

        .field-name {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 500;
            color: #333;
        }

        .field-type {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #667eea;
        }

        .field-nullable {
            text-align: center;
        }

        .nullable-yes {
            color: #38a169;
        }

        .nullable-no {
            color: #e53e3e;
        }

        .field-default {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #666;
            font-size: 12px;
        }

        .field-comment {
            color: #555;
            max-width: 200px;
        }

        .index-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin: 2px;
            white-space: nowrap;
        }

        .index-primary {
            background: linear-gradient(45deg, #f6e05e, #ecc94b);
            color: #744210;
        }

        .index-unique {
            background: linear-gradient(45deg, #68d391, #48bb78);
            color: #22543d;
        }

        .index-normal {
            background: linear-gradient(45deg, #63b3ed, #4299e1);
            color: #1a365d;
        }

        .index-fulltext {
            background: linear-gradient(45deg, #b794f4, #9f7aea);
            color: #44337a;
        }

        .index-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .index-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px dashed #e1e8ed;
        }

        .index-section h5 {
            font-size: 1rem;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .index-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .index-item {
            background: white;
            padding: 12px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .index-item .index-name {
            font-family: 'Monaco', 'Menlo', monospace;
            font-weight: 500;
            color: #333;
            min-width: 150px;
        }

        .index-item .index-columns {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #667eea;
            flex: 1;
        }

        .index-item .index-table {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #38a169;
            font-size: 12px;
        }

        .index-item-warning {
            background: #fffbeb;
            border: 1px solid #f59e0b;
        }

        .index-column-missing {
            color: #dc2626;
            font-weight: 600;
        }

        .index-warning {
            color: #dc2626;
            font-size: 12px;
            font-weight: 500;
            margin-left: auto;
            padding: 2px 8px;
            background: #fef2f2;
            border-radius: 4px;
        }

        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 768px) {
            .nav-container {
                flex-direction: column;
                height: auto;
                padding: 15px 0;
            }

            .nav-logo {
                margin-right: 0;
                margin-bottom: 10px;
            }

            .nav-menu {
                flex-wrap: wrap;
                justify-content: center;
            }

            .nav-item {
                padding: 8px 15px;
                font-size: 13px;
            }

            .converter-container,
            .ddl-container {
                grid-template-columns: 1fr;
            }
            
            .home-header h1 {
                font-size: 1.8rem;
            }

            .tools-grid {
                grid-template-columns: 1fr;
            }
            
            .buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            .ddl-table {
                font-size: 11px;
            }
            
            .ddl-table th,
            .ddl-table td {
                padding: 8px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- ÂØºËà™Ê†è -->
    <nav class="nav-bar">
        <div class="nav-container">
            <div class="nav-logo" onclick="showPage('home')">
                üõ†Ô∏è ÂºÄÂèëÂ∑•ÂÖ∑ÁÆ±
            </div>
            <ul class="nav-menu">
                <li class="nav-item active" data-page="home" onclick="showPage('home')">
                    <span class="nav-icon">üè†</span>
                    È¶ñÈ°µ
                </li>
                <li class="nav-item" data-page="php-json" onclick="showPage('php-json')">
                    <span class="nav-icon">üîÑ</span>
                    PHP/JSONËΩ¨Êç¢
                </li>
                <li class="nav-item" data-page="ddl-parser" onclick="showPage('ddl-parser')">
                    <span class="nav-icon">üìã</span>
                    DDLËß£ÊûêÂô®
                </li>
            </ul>
        </div>
    </nav>

    <!-- ‰∏ªÂÜÖÂÆπÂå∫Âüü -->
    <main class="main-content">
    <div class="container">
            <!-- È¶ñÈ°µ -->
            <div id="page-home" class="tool-page active">
                <div class="home-header">
            <h1>üõ†Ô∏è ÂºÄÂèëÂ∑•ÂÖ∑ÁÆ±</h1>
                    <p>ÂÆûÁî®ÁöÑÂºÄÂèëÂ∞èÂ∑•ÂÖ∑ÈõÜÂêàÔºåÊèêÂçá‰Ω†ÁöÑÂºÄÂèëÊïàÁéá</p>
        </div>

        <div class="tools-grid">
                    <div class="tool-card-home" onclick="showPage('php-json')">
                        <div class="card-icon">üîÑ</div>
                        <h3>PHPÊï∞ÁªÑ ‚áÑ JSON ËΩ¨Êç¢Âô®</h3>
                        <p>Âø´ÈÄüÂú® PHP Êï∞ÁªÑÊ†ºÂºèÂíå JSON Ê†ºÂºè‰πãÈó¥ËøõË°åËΩ¨Êç¢ÔºåÊîØÊåÅÂµåÂ•óÁªìÊûÑÂíåÂêÑÁßçÊï∞ÊçÆÁ±ªÂûã„ÄÇ</p>
                    </div>

                    <div class="tool-card-home" onclick="showPage('ddl-parser')">
                        <div class="card-icon">üìã</div>
                        <h3>DDL Ëß£ÊûêÂô®</h3>
                        <p>Ëß£Êûê MySQL DDL ËØ≠Âè•ÔºàCREATE TABLE / CREATE INDEXÔºâÔºåÁîüÊàêÊ∏ÖÊô∞ÁöÑË°®Ê†ºÂ±ïÁ§∫Â≠óÊÆµ‰ø°ÊÅØÂíåÁ¥¢ÂºïÂÖ≥Á≥ª„ÄÇ</p>
                    </div>
                </div>
            </div>

            <!-- PHP/JSON ËΩ¨Êç¢Âô® -->
            <div id="page-php-json" class="tool-page">
            <div class="tool-card">
                    <div class="tool-header">
                        <div class="icon">üîÑ</div>
                        <h2>PHPÊï∞ÁªÑ ‚áÑ JSON ËΩ¨Êç¢Âô®</h2>
                </div>

                <div class="converter-container">
                    <div class="converter-section">
                        <h3>PHPÊï∞ÁªÑÊ†ºÂºè</h3>
                        <textarea id="phpInput" placeholder="ËØ∑ËæìÂÖ•PHPÊï∞ÁªÑÊ†ºÂºèÔºå‰æãÂ¶ÇÔºö
array(
    'name' => 'Âº†‰∏â',
    'age' => 25,
    'skills' => array('PHP', 'JavaScript', 'Python')
)

ÊàñËÄÖÁÆÄÂåñÊ†ºÂºèÔºö
[
    'name' => 'Âº†‰∏â',
    'age' => 25,
    'skills' => ['PHP', 'JavaScript', 'Python']
]"></textarea>
                    </div>

                    <div class="converter-section">
                        <h3>JSONÊ†ºÂºè</h3>
                            <textarea id="jsonInput" placeholder='ËØ∑ËæìÂÖ•JSONÊ†ºÂºèÔºå‰æãÂ¶ÇÔºö
{
    "name": "Âº†‰∏â",
    "age": 25,
    "skills": ["PHP", "JavaScript", "Python"]
}'></textarea>
                    </div>
                </div>

                <div class="control-section">
                    <div class="buttons">
                        <button class="btn btn-primary" onclick="phpToJson()">PHP ‚Üí JSON</button>
                        <button class="btn btn-primary" onclick="jsonToPhp()">JSON ‚Üí PHP</button>
                            <button class="btn btn-secondary" onclick="clearPhpJson()">Ê∏ÖÁ©∫</button>
                    </div>

                        <div class="message error" id="phpJsonErrorMsg"></div>
                        <div class="message success" id="phpJsonSuccessMsg"></div>
                </div>
            </div>
        </div>

            <!-- DDL Ëß£ÊûêÂô® -->
            <div id="page-ddl-parser" class="tool-page">
                <div class="tool-card">
                    <div class="tool-header">
                        <div class="icon">üìã</div>
                        <h2>DDL Ëß£ÊûêÂô®</h2>
    </div>

                    <div class="ddl-container">
                        <div class="ddl-input-section">
                            <h3>ËæìÂÖ•DDLËØ≠Âè•</h3>
                            <textarea id="ddlInput" placeholder="ÊîØÊåÅ CREATE TABLE Âíå CREATE INDEX ËØ≠Âè•Ôºå‰æãÂ¶ÇÔºö

CREATE TABLE `users` (
    `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'Áî®Êà∑ID',
    `username` varchar(50) NOT NULL COMMENT 'Áî®Êà∑Âêç',
    `email` varchar(100) NOT NULL COMMENT 'ÈÇÆÁÆ±',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_username` (`username`),
    KEY `idx_email` (`email`)
) ENGINE=InnoDB COMMENT='Áî®Êà∑Ë°®';

CREATE INDEX idx_created_at ON users (created_at);
CREATE UNIQUE INDEX uk_phone ON users (phone);"></textarea>
                        </div>

                        <div class="ddl-control-section">
                            <div class="buttons">
                                <button class="btn btn-primary" onclick="parseDDL()">Ëß£ÊûêDDL</button>
                                <button class="btn btn-secondary" onclick="clearDDL()">Ê∏ÖÁ©∫</button>
                                <button class="btn btn-secondary" onclick="copyTableAsMarkdown()">Â§çÂà∂‰∏∫Markdown</button>
                            </div>
                            <div class="message error" id="ddlErrorMsg"></div>
                            <div class="message success" id="ddlSuccessMsg"></div>
                        </div>
                    </div>

                    <div class="ddl-output-section" id="ddlOutput">
                        <div class="ddl-placeholder">
                            <span>üìä</span>
                            <p>Ëß£ÊûêÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // ==================== È°µÈù¢ÂØºËà™ ====================
        function showPage(pageId) {
            // ÈöêËóèÊâÄÊúâÈ°µÈù¢
            document.querySelectorAll('.tool-page').forEach(page => {
                page.classList.remove('active');
            });
            
            // ÊòæÁ§∫ÁõÆÊ†áÈ°µÈù¢
            document.getElementById('page-' + pageId).classList.add('active');
            
            // Êõ¥Êñ∞ÂØºËà™ËèúÂçïÁä∂ÊÄÅ
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.page === pageId) {
                    item.classList.add('active');
                }
            });

            // Êõ¥Êñ∞ URL hash
            window.location.hash = pageId;
        }

        // È°µÈù¢Âä†ËΩΩÊó∂Ê£ÄÊü• hash
        window.addEventListener('load', () => {
            const hash = window.location.hash.slice(1);
            if (hash && document.getElementById('page-' + hash)) {
                showPage(hash);
            }
        });

        // ==================== PHP/JSON ËΩ¨Êç¢ÂäüËÉΩ ====================
        
        function showPhpJsonMessage(message, type = 'success') {
            const errorDiv = document.getElementById('phpJsonErrorMsg');
            const successDiv = document.getElementById('phpJsonSuccessMsg');
            
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';
            
            if (type === 'error') {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            } else {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
            }
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
            }, 3000);
        }

        function phpToJson() {
            const phpInput = document.getElementById('phpInput').value.trim();
            if (!phpInput) {
                showPhpJsonMessage('ËØ∑ËæìÂÖ•PHPÊï∞ÁªÑÊ†ºÂºè', 'error');
                return;
            }

            try {
                let jsonResult;
                try {
                    jsonResult = smartParsePHPArray(phpInput);
                } catch (smartError) {
                    jsonResult = parsePHPArray(phpInput);
                }
                
                document.getElementById('jsonInput').value = JSON.stringify(jsonResult, null, 2);
                showPhpJsonMessage('ËΩ¨Êç¢ÊàêÂäüÔºÅ');
            } catch (error) {
                showPhpJsonMessage('ËΩ¨Êç¢Â§±Ë¥•Ôºö' + error.message, 'error');
            }
        }

        function jsonToPhp() {
            const jsonInput = document.getElementById('jsonInput').value.trim();
            if (!jsonInput) {
                showPhpJsonMessage('ËØ∑ËæìÂÖ•JSONÊ†ºÂºè', 'error');
                return;
            }

            try {
                const jsonObj = JSON.parse(jsonInput);
                const phpResult = convertToPHP(jsonObj);
                document.getElementById('phpInput').value = phpResult;
                showPhpJsonMessage('ËΩ¨Êç¢ÊàêÂäüÔºÅ');
            } catch (error) {
                showPhpJsonMessage('ËΩ¨Êç¢Â§±Ë¥•ÔºöËØ∑Ê£ÄÊü•JSONÊ†ºÂºèÊòØÂê¶Ê≠£Á°Æ', 'error');
            }
        }

        function clearPhpJson() {
            document.getElementById('phpInput').value = '';
            document.getElementById('jsonInput').value = '';
            document.getElementById('phpJsonErrorMsg').style.display = 'none';
            document.getElementById('phpJsonSuccessMsg').style.display = 'none';
        }

        // PHPÊï∞ÁªÑËß£ÊûêÂô®
        function parsePHPArray(phpString) {
                let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
                cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
                cleanString = cleanString.replace(/;$/, '');
                cleanString = replaceArraySyntax(cleanString);
                cleanString = replaceArrowSyntax(cleanString);
                cleanString = replaceSingleQuotes(cleanString);
                cleanString = replacePhpValues(cleanString);
                cleanString = fixKeyFormat(cleanString);
                return JSON.parse(cleanString);
        }
        
        function replaceArraySyntax(str) {
            let result = str;
            let changed = true;
            while (changed) {
                const before = result;
                result = result.replace(/\barray\s*\(/g, '[');
                changed = before !== result;
            }
            return balanceParentheses(result);
        }
        
        function balanceParentheses(str) {
            let result = '';
            let inString = false;
            let stringChar = '';
            let escaped = false;
            
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                
                if (escaped) {
                    result += char;
                    escaped = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escaped = true;
                    continue;
                }
                
                if (!inString && (char === '"' || char === "'")) {
                    inString = true;
                    stringChar = char;
                    result += char;
                    continue;
                }
                
                if (inString && char === stringChar) {
                    inString = false;
                    stringChar = '';
                    result += char;
                    continue;
                }
                
                if (inString) {
                    result += char;
                    continue;
                }
                
                if (char === '(') {
                    result += '[';
                } else if (char === ')') {
                    result += ']';
                } else {
                    result += char;
                }
            }
            
            return result;
        }
        
        function replaceArrowSyntax(str) {
            return str.replace(/((?:'[^'\\]*(?:\\.[^'\\]*)*'|"[^"\\]*(?:\\.[^"\\]*)*"|\w+|\d+))\s*=>\s*/g, function(match, key) {
                if (/^\d+$/.test(key)) return key + ': ';
                if (key.match(/^['"]/)) return key + ': ';
                return '"' + key + '": ';
            });
        }
        
        function fixKeyFormat(str) {
            return str.replace(/(\w+)(\s*:\s*)/g, function(match, key, colon) {
                if (!/^\d+$/.test(key) && !key.match(/^['"]/)) {
                    return '"' + key + '"' + colon;
                }
                return match;
            });
        }
        
        function replaceSingleQuotes(str) {
            let result = '';
            let inDoubleQuote = false;
            let escaped = false;
            
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                
                if (escaped) {
                    result += char;
                    escaped = false;
                    continue;
                }
                
                if (char === '\\') {
                    result += char;
                    escaped = true;
                    continue;
                }
                
                if (char === '"') {
                    inDoubleQuote = !inDoubleQuote;
                    result += char;
                    continue;
                }
                
                if (inDoubleQuote) {
                    result += char;
                    continue;
                }
                
                if (char === "'") {
                    result += '"';
                } else {
                    result += char;
                }
            }
            
            return result;
        }
        
        function replacePhpValues(str) {
            let result = str.replace(/\b(true|false|null|TRUE|FALSE|NULL)\b/g, function(match) {
                return match.toLowerCase();
            });
            result = result.replace(/\bINF\b/g, '"Infinity"');
            result = result.replace(/\bNAN\b/g, '"NaN"');
            result = result.replace(/\b-INF\b/g, '"-Infinity"');
            return result;
        }
        
        // Êô∫ËÉΩPHPÊï∞ÁªÑËß£ÊûêÂô®
        function smartParsePHPArray(phpString) {
                let cleanString = phpString.replace(/<\?php|<\?|\?>/g, '').trim();
                cleanString = cleanString.replace(/^\$\w+\s*=\s*/, '');
                cleanString = cleanString.replace(/;$/, '');
                
                const tokens = tokenize(cleanString);
            return parseTokens(tokens);
        }
        
        function tokenize(str) {
            const tokens = [];
            let i = 0;
            
            while (i < str.length) {
                const char = str[i];
                
                if (/\s/.test(char)) { i++; continue; }
                
                if (char === '"' || char === "'") {
                    const quote = char;
                    let value = '';
                    i++;
                    while (i < str.length && str[i] !== quote) {
                        if (str[i] === '\\' && i + 1 < str.length) {
                            value += str[i] + str[i + 1];
                            i += 2;
                        } else {
                            value += str[i];
                            i++;
                        }
                    }
                    tokens.push({type: 'STRING', value: value, quote: quote});
                    i++;
                    continue;
                }
                
                if (/\d/.test(char) || (char === '-' && /\d/.test(str[i + 1]))) {
                    let value = '';
                    if (char === '-') { value += char; i++; }
                    while (i < str.length && /[\d.]/.test(str[i])) {
                        value += str[i];
                        i++;
                    }
                    tokens.push({type: 'NUMBER', value: parseFloat(value)});
                    continue;
                }
                
                if (/[a-zA-Z_]/.test(char)) {
                    let value = '';
                    while (i < str.length && /[a-zA-Z0-9_]/.test(str[i])) {
                        value += str[i];
                        i++;
                    }
                    
                    if (value === 'array') {
                        tokens.push({type: 'ARRAY'});
                    } else if (['true', 'false', 'null'].includes(value.toLowerCase())) {
                        tokens.push({type: 'LITERAL', value: value.toLowerCase()});
                    } else {
                        tokens.push({type: 'IDENTIFIER', value: value});
                    }
                    continue;
                }
                
                if (char === '=' && str[i + 1] === '>') {
                    tokens.push({type: 'ARROW'});
                    i += 2;
                    continue;
                }
                
                const singleChars = {'[': 'LBRACKET', ']': 'RBRACKET', '(': 'LPAREN', ')': 'RPAREN', ',': 'COMMA'};
                if (singleChars[char]) {
                    tokens.push({type: singleChars[char]});
                    i++;
                    continue;
                }
                
                i++;
            }
            
            return tokens;
        }
        
        function parseTokens(tokens) {
            let pos = 0;
            
            function parseValue() {
                const token = tokens[pos];
                if (!token) throw new Error('ÊÑèÂ§ñÁöÑËæìÂÖ•ÁªìÊùü');
                
                if (token.type === 'STRING') { pos++; return token.value; }
                if (token.type === 'NUMBER') { pos++; return token.value; }
                if (token.type === 'LITERAL') {
                    pos++;
                    return token.value === 'true' ? true : token.value === 'false' ? false : null;
                }
                if (token.type === 'LBRACKET' || token.type === 'ARRAY') return parseArray();
                
                throw new Error('Êó†Ê≥ïËß£ÊûêÁöÑÂÄº: ' + JSON.stringify(token));
            }
            
            function parseArray() {
                const result = {};
                let isIndexedArray = true;
                let index = 0;
                
                if (tokens[pos]?.type === 'ARRAY') {
                    pos++;
                    if (tokens[pos]?.type === 'LPAREN') pos++;
                } else if (tokens[pos]?.type === 'LBRACKET') {
                    pos++;
                }
                
                while (pos < tokens.length && tokens[pos]?.type !== 'RBRACKET' && tokens[pos]?.type !== 'RPAREN') {
                    let key = index;
                    
                    if (pos + 1 < tokens.length && tokens[pos + 1]?.type === 'ARROW') {
                        key = parseValue();
                        pos++;
                        isIndexedArray = false;
                    }
                    
                    const value = parseValue();
                    result[key] = value;
                    
                    if (isIndexedArray) index++;
                    if (tokens[pos]?.type === 'COMMA') pos++;
                }
                
                if (tokens[pos]?.type === 'RBRACKET' || tokens[pos]?.type === 'RPAREN') pos++;
                
                if (isIndexedArray) {
                    const arr = [];
                    for (let i = 0; i < index; i++) arr[i] = result[i];
                    return arr;
                }
                
                return result;
            }
            
            return parseValue();
        }
        
        // ËΩ¨Êç¢‰∏∫PHPÊ†ºÂºè
        function convertToPHP(obj, indent = 0) {
            const spaces = '    '.repeat(indent);
            const nextSpaces = '    '.repeat(indent + 1);
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return '[]';
                
                let result = '[\n';
                obj.forEach((item, index) => {
                    result += nextSpaces + convertToPHP(item, indent + 1);
                    if (index < obj.length - 1) result += ',';
                    result += '\n';
                });
                result += spaces + ']';
                return result;
            } else if (typeof obj === 'object' && obj !== null) {
                const keys = Object.keys(obj);
                if (keys.length === 0) return '[]';
                
                const isNumericKeys = keys.every(key => /^\d+$/.test(key));
                const isSequentialKeys = isNumericKeys && keys.map(Number).sort((a, b) => a - b).every((num, index) => num === index);
                
                let result = '[\n';
                keys.forEach((key, index) => {
                    let quotedKey;
                    if (isNumericKeys && isSequentialKeys) {
                        quotedKey = '';
                    } else if (/^\d+$/.test(key)) {
                        quotedKey = key + ' => ';
                    } else {
                        const escapedKey = key.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                        quotedKey = `'${escapedKey}' => `;
                    }
                    
                    result += nextSpaces + quotedKey + convertToPHP(obj[key], indent + 1);
                    if (index < keys.length - 1) result += ',';
                    result += '\n';
                });
                result += spaces + ']';
                return result;
            } else if (typeof obj === 'string') {
                const escaped = obj.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
                return `'${escaped}'`;
            } else if (typeof obj === 'boolean') {
                return obj ? 'true' : 'false';
            } else if (obj === null) {
                return 'null';
            } else if (typeof obj === 'number') {
                if (isNaN(obj)) return 'NAN';
                if (!isFinite(obj)) return obj > 0 ? 'INF' : '-INF';
                return obj.toString();
            } else {
                return obj.toString();
            }
        }

        // ==================== DDLËß£ÊûêÂäüËÉΩ ====================
        
        function showDDLMessage(message, type = 'success') {
            const errorDiv = document.getElementById('ddlErrorMsg');
            const successDiv = document.getElementById('ddlSuccessMsg');
            
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';
            
            if (type === 'error') {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            } else {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
            }
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
            }, 3000);
        }

        function parseDDL() {
            const ddlInput = document.getElementById('ddlInput').value.trim();
            if (!ddlInput) {
                showDDLMessage('ËØ∑ËæìÂÖ•DDLËØ≠Âè•', 'error');
                return;
            }

            try {
                const result = parseDDLStatements(ddlInput);
                renderDDLResult(result);
                showDDLMessage('Ëß£ÊûêÊàêÂäüÔºÅ');
            } catch (error) {
                console.error('DDLËß£ÊûêÈîôËØØ:', error);
                showDDLMessage('Ëß£ÊûêÂ§±Ë¥•Ôºö' + error.message, 'error');
            }
        }

        function clearDDL() {
            document.getElementById('ddlInput').value = '';
            document.getElementById('ddlOutput').innerHTML = `
                <div class="ddl-placeholder">
                    <span>üìä</span>
                    <p>Ëß£ÊûêÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå</p>
                </div>
            `;
            document.getElementById('ddlErrorMsg').style.display = 'none';
            document.getElementById('ddlSuccessMsg').style.display = 'none';
        }

        // Ëß£ÊûêÂ§öÊù°DDLËØ≠Âè•
        function parseDDLStatements(ddl) {
            // ÁßªÈô§Ê≥®Èáä
            ddl = ddl.replace(/--.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
            
            const tables = {};
            const standaloneIndexes = [];
            
            // ÂàÜÂâ≤ËØ≠Âè•
            const statements = ddl.split(';').map(s => s.trim()).filter(s => s.length > 0);
            
            for (const stmt of statements) {
                // Ëß£Êûê CREATE TABLE
                if (/CREATE\s+TABLE/i.test(stmt)) {
                    const tableResult = parseCreateTable(stmt);
                    tables[tableResult.tableName.toLowerCase()] = tableResult;
                }
                // Ëß£Êûê CREATE INDEX
                else if (/CREATE\s+(UNIQUE\s+)?INDEX/i.test(stmt)) {
                    const indexResult = parseCreateIndex(stmt);
                    if (indexResult) {
                        const tableName = indexResult.tableName.toLowerCase();
                        if (tables[tableName]) {
                            const table = tables[tableName];
                            const fieldNames = new Set(table.fields.map(f => f.name.toLowerCase()));
                            
                            // Ê£ÄÊü•Á¥¢ÂºïÂ≠óÊÆµÊòØÂê¶Â≠òÂú®
                            indexResult.index.missingColumns = [];
                            for (const col of indexResult.index.columns) {
                                if (!fieldNames.has(col.toLowerCase())) {
                                    indexResult.index.missingColumns.push(col);
                                }
                            }
                            
                            // Â∞ÜÁ¥¢ÂºïÊ∑ªÂä†Âà∞Â∑≤ÊúâÁöÑË°®‰∏≠
                            table.indexes.push(indexResult.index);
                            
                            // Êõ¥Êñ∞Â≠óÊÆµÁöÑÁ¥¢Âºï‰ø°ÊÅØ
                            for (const field of table.fields) {
                                if (indexResult.index.columns.some(col => col.toLowerCase() === field.name.toLowerCase())) {
                                    field.indexes.push({
                                        name: indexResult.index.name,
                                        type: indexResult.index.type,
                                        isFirst: indexResult.index.columns[0].toLowerCase() === field.name.toLowerCase()
                                    });
                                }
                            }
                        } else {
                            // Ë°®‰∏çÂ≠òÂú®ÔºåËÆ∞ÂΩï‰∏∫Áã¨Á´ãÁ¥¢Âºï
                            standaloneIndexes.push(indexResult);
                        }
                    }
                }
            }
            
            return {
                tables: Object.values(tables),
                standaloneIndexes
            };
        }

        // Ëß£Êûê CREATE TABLE ËØ≠Âè•
        function parseCreateTable(ddl) {
            // ÊèêÂèñË°®Âêç
            const tableNameMatch = ddl.match(/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?[`"']?(\w+)[`"']?/i);
            if (!tableNameMatch) {
                throw new Error('Êó†Ê≥ïËØÜÂà´CREATE TABLEËØ≠Âè•');
            }
            const tableName = tableNameMatch[1];

            // ÊèêÂèñË°®Ê≥®Èáä
            const tableCommentMatch = ddl.match(/\)\s*[^;]*COMMENT\s*=?\s*['"]([^'"]+)['"]/i);
            const tableComment = tableCommentMatch ? tableCommentMatch[1] : '';

            // ÊèêÂèñÊã¨Âè∑ÂÜÖÁöÑÂÜÖÂÆπ
            const contentMatch = ddl.match(/CREATE\s+TABLE[^(]*\(([\s\S]+)\)[^)]*$/i);
            if (!contentMatch) {
                throw new Error('Êó†Ê≥ïËß£ÊûêË°®ÂÆö‰πâÂÜÖÂÆπ');
            }
            
            const content = contentMatch[1];
            const definitions = splitDefinitions(content);
            
            const fields = [];
            const indexes = [];
            
            for (const def of definitions) {
                const trimmedDef = def.trim();
                if (!trimmedDef) continue;
                
                if (/^(PRIMARY\s+KEY|UNIQUE\s+KEY|UNIQUE\s+INDEX|KEY|INDEX|FULLTEXT\s+KEY|FULLTEXT\s+INDEX|SPATIAL\s+KEY|SPATIAL\s+INDEX|CONSTRAINT)/i.test(trimmedDef)) {
                    const indexInfo = parseInlineIndex(trimmedDef);
                    if (indexInfo) indexes.push(indexInfo);
                } else if (/^[`"']?\w+[`"']?\s+/i.test(trimmedDef)) {
                    const fieldInfo = parseField(trimmedDef);
                    if (fieldInfo) fields.push(fieldInfo);
                }
            }
            
            // Ëé∑ÂèñÊâÄÊúâÂ≠óÊÆµÂêçÔºàÂ∞èÂÜôÔºâ
            const fieldNames = new Set(fields.map(f => f.name.toLowerCase()));
            
            // ‰∏∫Â≠óÊÆµÊ∑ªÂä†Á¥¢Âºï‰ø°ÊÅØÔºåÂπ∂Ê£ÄÊü•Á¥¢ÂºïÂ≠óÊÆµÊòØÂê¶Â≠òÂú®
            for (const field of fields) {
                field.indexes = [];
                for (const index of indexes) {
                    if (index.columns.some(col => col.toLowerCase() === field.name.toLowerCase())) {
                        field.indexes.push({
                            name: index.name,
                            type: index.type,
                            isFirst: index.columns[0].toLowerCase() === field.name.toLowerCase()
                        });
                    }
                }
            }
            
            // Ê£ÄÊü•ÊØè‰∏™Á¥¢ÂºïÁöÑÂ≠óÊÆµÊòØÂê¶ÈÉΩÂ≠òÂú®
            for (const index of indexes) {
                index.missingColumns = [];
                for (const col of index.columns) {
                    if (!fieldNames.has(col.toLowerCase())) {
                        index.missingColumns.push(col);
                    }
                }
            }
            
            return { tableName, tableComment, fields, indexes };
        }

        // Ëß£Êûê CREATE INDEX ËØ≠Âè•
        function parseCreateIndex(stmt) {
            // CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON table_name (column_list)
            const match = stmt.match(/CREATE\s+(UNIQUE\s+|FULLTEXT\s+|SPATIAL\s+)?INDEX\s+[`"']?(\w+)[`"']?\s+ON\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
            
            if (!match) return null;
            
            const typeStr = (match[1] || '').trim().toUpperCase();
            let type = 'INDEX';
            if (typeStr === 'UNIQUE') type = 'UNIQUE';
            else if (typeStr === 'FULLTEXT') type = 'FULLTEXT';
            else if (typeStr === 'SPATIAL') type = 'SPATIAL';
            
            const name = match[2];
            const tableName = match[3];
            const columns = parseIndexColumns(match[4]);
            
            return {
                tableName,
                index: { type, name, columns }
            };
        }

        // ÂàÜÂâ≤ÂÆö‰πâÔºàÂ§ÑÁêÜÊã¨Âè∑ÂµåÂ•óÔºâ
        function splitDefinitions(content) {
            const definitions = [];
            let current = '';
            let depth = 0;
            let inString = false;
            let stringChar = '';
            
            for (let i = 0; i < content.length; i++) {
                const char = content[i];
                
                if (inString) {
                    current += char;
                    if (char === stringChar && content[i - 1] !== '\\') {
                        inString = false;
                    }
                    continue;
                }
                
                if (char === "'" || char === '"' || char === '`') {
                    inString = true;
                    stringChar = char;
                    current += char;
                    continue;
                }
                
                if (char === '(') { depth++; current += char; continue; }
                if (char === ')') { depth--; current += char; continue; }
                
                if (char === ',' && depth === 0) {
                    definitions.push(current.trim());
                    current = '';
                    continue;
                }
                
                current += char;
            }
            
            if (current.trim()) definitions.push(current.trim());
            return definitions;
        }

        // Ëß£ÊûêÂ≠óÊÆµ
        function parseField(fieldDef) {
            // ËßÑËåÉÂåñÁ©∫ÁôΩÂ≠óÁ¨¶ÔºöÂ∞ÜÂ§ö‰∏™Á©∫ÁôΩÂ≠óÁ¨¶ÔºàÂåÖÊã¨Êç¢Ë°åÔºâÊõøÊç¢‰∏∫Âçï‰∏™Á©∫Ê†º
            const normalizedDef = fieldDef.replace(/\s+/g, ' ').trim();
            
            // ÂåπÈÖçÂ≠óÊÆµÂêçÂíåÂâ©‰ΩôÂÆö‰πâ
            const nameMatch = normalizedDef.match(/^[`"']?(\w+)[`"']?\s+(.+)$/i);
            if (!nameMatch) return null;
            
            const name = nameMatch[1];
            const rest = nameMatch[2];
            
            // ÂåπÈÖçÁ±ªÂûãÔºåÊîØÊåÅÊõ¥Â§öÊ†ºÂºè
            const typeMatch = rest.match(/^(\w+(?:\s*\([^)]+\))?(?:\s+unsigned)?(?:\s+zerofill)?)/i);
            const type = typeMatch ? typeMatch[1].trim().replace(/\s+/g, ' ') : 'UNKNOWN';
            
            const nullable = !/\bNOT\s+NULL\b/i.test(rest);
            
            let defaultValue = null;
            const defaultMatch = rest.match(/DEFAULT\s+('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|[\w()]+)/i);
            if (defaultMatch) {
                defaultValue = defaultMatch[1].replace(/^['"]|['"]$/g, '');
            }
            
            const autoIncrement = /\bAUTO_INCREMENT\b/i.test(rest);
            
            let comment = '';
            const commentMatch = rest.match(/COMMENT\s+['"]([^'"]*)['"]/i);
            if (commentMatch) comment = commentMatch[1];
            
            const isPrimaryKey = /\bPRIMARY\s+KEY\b/i.test(rest);
            
            return { name, type, nullable, defaultValue, autoIncrement, comment, isPrimaryKey, indexes: [] };
        }

        // Ëß£ÊûêÂÜÖËÅîÁ¥¢ÂºïÔºàCREATE TABLE ÂÜÖÁöÑÁ¥¢ÂºïÂÆö‰πâÔºâ
        function parseInlineIndex(indexDef) {
            // ËßÑËåÉÂåñÁ©∫ÁôΩÂ≠óÁ¨¶
            const normalizedDef = indexDef.replace(/\s+/g, ' ').trim();
            
            let type = 'INDEX';
            let name = '';
            let columns = [];
            
            if (/^PRIMARY\s+KEY/i.test(normalizedDef)) {
                type = 'PRIMARY';
                name = 'PRIMARY';
                const colMatch = normalizedDef.match(/\(([^)]+)\)/);
                if (colMatch) columns = parseIndexColumns(colMatch[1]);
            }
            else if (/^UNIQUE\s+(KEY|INDEX)/i.test(normalizedDef)) {
                type = 'UNIQUE';
                const nameMatch = normalizedDef.match(/^UNIQUE\s+(?:KEY|INDEX)\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
                if (nameMatch) {
                    name = nameMatch[1];
                    columns = parseIndexColumns(nameMatch[2]);
                }
            }
            else if (/^FULLTEXT\s+(KEY|INDEX)/i.test(normalizedDef)) {
                type = 'FULLTEXT';
                const nameMatch = normalizedDef.match(/^FULLTEXT\s+(?:KEY|INDEX)\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
                if (nameMatch) {
                    name = nameMatch[1];
                    columns = parseIndexColumns(nameMatch[2]);
                }
            }
            else if (/^(KEY|INDEX)/i.test(normalizedDef)) {
                type = 'INDEX';
                const nameMatch = normalizedDef.match(/^(?:KEY|INDEX)\s+[`"']?(\w+)[`"']?\s*\(([^)]+)\)/i);
                if (nameMatch) {
                    name = nameMatch[1];
                    columns = parseIndexColumns(nameMatch[2]);
                }
            }
            
            if (columns.length === 0) return null;
            return { type, name, columns };
        }

        // Ëß£ÊûêÁ¥¢ÂºïÂàó
        function parseIndexColumns(columnsStr) {
            return columnsStr.split(',').map(col => {
                const match = col.trim().match(/[`"']?(\w+)[`"']?/);
                return match ? match[1] : '';
            }).filter(Boolean);
        }

        // Ê∏≤ÊüìDDLÁªìÊûú
        function renderDDLResult(result) {
            const output = document.getElementById('ddlOutput');
            let html = '';
            
            // Ê∏≤ÊüìÊØè‰∏™Ë°®
            for (const table of result.tables) {
                html += renderTableResult(table);
            }
            
            // Ê∏≤ÊüìÁã¨Á´ãÁ¥¢Âºï
            if (result.standaloneIndexes.length > 0) {
                html += `
                    <div class="index-section">
                        <h5>üîó Áã¨Á´ãÁ¥¢ÂºïÔºàÊú™ÊâæÂà∞ÂØπÂ∫îË°®Ôºâ</h5>
                        <div class="index-list">
                `;
                
                for (const item of result.standaloneIndexes) {
                    const badgeClass = getIndexBadgeClass(item.index.type);
                    html += `
                        <div class="index-item">
                            <span class="index-badge ${badgeClass}">${getIndexTypeLabel(item.index.type)}</span>
                            <span class="index-name">${escapeHtml(item.index.name)}</span>
                            <span class="index-table">ON ${escapeHtml(item.tableName)}</span>
                            <span class="index-columns">(${item.index.columns.map(c => escapeHtml(c)).join(', ')})</span>
                        </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            if (!html) {
                html = `
                    <div class="ddl-placeholder">
                        <span>‚ö†Ô∏è</span>
                        <p>Êú™ËÉΩËß£ÊûêÂá∫ÊúâÊïàÁöÑDDLËØ≠Âè•</p>
                    </div>
                `;
            }
            
            output.innerHTML = html;
        }

        // Ê∏≤ÊüìÂçï‰∏™Ë°®ÁöÑÁªìÊûú
        function renderTableResult(table) {
            let html = `
                <div class="table-info">
                    <h4>
                        üìã Ë°®Âêç: <span class="table-name">${escapeHtml(table.tableName)}</span>
                        ${table.tableComment ? `<span class="table-comment">Ôºà${escapeHtml(table.tableComment)}Ôºâ</span>` : ''}
                    </h4>
                </div>
                
                <table class="ddl-table">
                    <thead>
                        <tr>
                            <th>Â≠óÊÆµÂêç</th>
                            <th>Á±ªÂûã</th>
                            <th>ÂÖÅËÆ∏NULL</th>
                            <th>ÈªòËÆ§ÂÄº</th>
                            <th>Á¥¢Âºï</th>
                            <th>Ê≥®Èáä</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const field of table.fields) {
                const indexBadges = renderIndexBadges(field);
                
                html += `
                    <tr>
                        <td class="field-name">${escapeHtml(field.name)}${field.autoIncrement ? ' <small style="color:#999">(AI)</small>' : ''}</td>
                        <td class="field-type">${escapeHtml(field.type)}</td>
                        <td class="field-nullable ${field.nullable ? 'nullable-yes' : 'nullable-no'}">${field.nullable ? '‚úì' : '‚úó'}</td>
                        <td class="field-default">${field.defaultValue !== null ? escapeHtml(field.defaultValue) : '<span style="color:#999">-</span>'}</td>
                        <td class="index-badges">${indexBadges || '<span style="color:#999">-</span>'}</td>
                        <td class="field-comment">${escapeHtml(field.comment) || '<span style="color:#999">-</span>'}</td>
                    </tr>
                `;
            }
            
            html += '</tbody></table>';
            
            // Ê∑ªÂä†Á¥¢ÂºïÂàóË°®
            if (table.indexes.length > 0) {
                html += `
                    <div class="index-section">
                        <h5>üîë Á¥¢ÂºïÂàóË°®</h5>
                        <div class="index-list">
                `;
                
                for (const index of table.indexes) {
                    const badgeClass = getIndexBadgeClass(index.type);
                    const hasMissing = index.missingColumns && index.missingColumns.length > 0;
                    const columnsHtml = index.columns.map(c => {
                        const isMissing = index.missingColumns && index.missingColumns.some(m => m.toLowerCase() === c.toLowerCase());
                        if (isMissing) {
                            return `<span class="index-column-missing" title="Â≠óÊÆµ‰∏çÂ≠òÂú®">${escapeHtml(c)} ‚ö†Ô∏è</span>`;
                        }
                        return escapeHtml(c);
                    }).join(', ');
                    
                    html += `
                        <div class="index-item ${hasMissing ? 'index-item-warning' : ''}">
                            <span class="index-badge ${badgeClass}">${getIndexTypeLabel(index.type)}</span>
                            <span class="index-name">${escapeHtml(index.name)}</span>
                            <span class="index-columns">(${columnsHtml})</span>
                            ${hasMissing ? '<span class="index-warning">Â≠óÊÆµ‰∏çÂ≠òÂú®</span>' : ''}
                        </div>
                    `;
                }
                
                html += '</div></div>';
            }
            
            return html;
        }

        // Ê∏≤ÊüìÁ¥¢ÂºïÂæΩÁ´†
        function renderIndexBadges(field) {
            if (field.indexes.length === 0 && !field.isPrimaryKey) return '';
            
            let badges = '';
            
            if (field.isPrimaryKey) {
                badges += `<span class="index-badge index-primary">üîë ‰∏ªÈîÆ</span>`;
            }
            
            for (const idx of field.indexes) {
                if (idx.type === 'PRIMARY' && field.isPrimaryKey) continue;
                
                const badgeClass = getIndexBadgeClass(idx.type);
                const label = getIndexTypeLabel(idx.type);
                const prefix = idx.isFirst ? '' : '‚Ü≥ ';
                
                badges += `<span class="index-badge ${badgeClass}" title="${escapeHtml(idx.name)}">${prefix}${label}</span>`;
            }
            
            return badges;
        }

        function getIndexBadgeClass(type) {
            switch (type) {
                case 'PRIMARY': return 'index-primary';
                case 'UNIQUE': return 'index-unique';
                case 'FULLTEXT': return 'index-fulltext';
                default: return 'index-normal';
            }
        }

        function getIndexTypeLabel(type) {
            switch (type) {
                case 'PRIMARY': return 'üîë ‰∏ªÈîÆ';
                case 'UNIQUE': return 'üéØ ÂîØ‰∏Ä';
                case 'FULLTEXT': return 'üìù ÂÖ®Êñá';
                default: return 'üìá Á¥¢Âºï';
            }
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Â§çÂà∂‰∏∫MarkdownË°®Ê†º
        function copyTableAsMarkdown() {
            const ddlInput = document.getElementById('ddlInput').value.trim();
            if (!ddlInput) {
                showDDLMessage('ËØ∑ÂÖàËæìÂÖ•Âπ∂Ëß£ÊûêDDLËØ≠Âè•', 'error');
                return;
            }

            try {
                const result = parseDDLStatements(ddlInput);
                const markdown = generateMarkdownTable(result);
                
                navigator.clipboard.writeText(markdown).then(() => {
                    showDDLMessage('Â∑≤Â§çÂà∂MarkdownÂà∞Ââ™Ë¥¥ÊùøÔºÅ');
                }).catch(err => {
                    const textarea = document.createElement('textarea');
                    textarea.value = markdown;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showDDLMessage('Â∑≤Â§çÂà∂MarkdownÂà∞Ââ™Ë¥¥ÊùøÔºÅ');
                });
            } catch (error) {
                showDDLMessage('Â§çÂà∂Â§±Ë¥•Ôºö' + error.message, 'error');
            }
        }

        function generateMarkdownTable(result) {
            let md = '';
            
            for (const table of result.tables) {
                md += `## Ë°®Âêç: ${table.tableName}`;
                if (table.tableComment) md += ` (${table.tableComment})`;
                md += '\n\n';
                
                md += '| Â≠óÊÆµÂêç | Á±ªÂûã | ÂÖÅËÆ∏NULL | ÈªòËÆ§ÂÄº | Á¥¢Âºï | Ê≥®Èáä |\n';
                md += '|--------|------|----------|--------|------|------|\n';
                
                for (const field of table.fields) {
                    const indexLabels = [];
                    if (field.isPrimaryKey) indexLabels.push('‰∏ªÈîÆ');
                    for (const idx of field.indexes) {
                        if (idx.type === 'PRIMARY' && field.isPrimaryKey) continue;
                        indexLabels.push(`${getIndexTypeText(idx.type)}(${idx.name})`);
                    }
                    
                    md += `| ${field.name}${field.autoIncrement ? ' (AI)' : ''} `;
                    md += `| ${field.type} `;
                    md += `| ${field.nullable ? 'ÊòØ' : 'Âê¶'} `;
                    md += `| ${field.defaultValue !== null ? field.defaultValue : '-'} `;
                    md += `| ${indexLabels.length > 0 ? indexLabels.join(', ') : '-'} `;
                    md += `| ${field.comment || '-'} |\n`;
                }
                
                if (table.indexes.length > 0) {
                    md += '\n### Á¥¢ÂºïÂàóË°®\n\n';
                    md += '| Á¥¢ÂºïÂêç | Á±ªÂûã | Â≠óÊÆµ |\n';
                    md += '|--------|------|------|\n';
                    
                    for (const index of table.indexes) {
                        md += `| ${index.name} | ${getIndexTypeText(index.type)} | ${index.columns.join(', ')} |\n`;
                    }
                }
                
                md += '\n';
            }
            
            return md;
        }

        function getIndexTypeText(type) {
            switch (type) {
                case 'PRIMARY': return '‰∏ªÈîÆ';
                case 'UNIQUE': return 'ÂîØ‰∏ÄÁ¥¢Âºï';
                case 'FULLTEXT': return 'ÂÖ®ÊñáÁ¥¢Âºï';
                default: return 'ÊôÆÈÄöÁ¥¢Âºï';
            }
        }
    </script>
</body>
</html>
